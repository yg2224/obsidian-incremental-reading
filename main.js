/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IncrementalReadingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/views/IncrementalReadingView.ts
var import_obsidian4 = require("obsidian");

// src/components/Modal.ts
var import_obsidian = require("obsidian");

// src/i18n/translations.ts
var translations = {
  en: {
    common: {
      ok: "OK",
      cancel: "Cancel",
      save: "Save",
      delete: "Delete",
      edit: "Edit",
      add: "Add",
      remove: "Remove",
      confirm: "Confirm",
      close: "Close",
      reset: "Reset",
      search: "Search",
      loading: "Loading...",
      error: "Error",
      success: "Success",
      warning: "Warning"
    },
    view: {
      title: "Incremental Reading",
      subtitle: `"Unfold the scroll of silent affection: With the <span class="chance">chance of waiting and roaming...</span><br>Through stars we meet, three autumns' frost prints on the hooves."`,
      statusTemplate: "Roaming through {count} documents",
      noDocuments: "No documents in roaming list",
      openDocument: "Open Document",
      actionBar: {
        continue: "Continue Reading",
        smartRecommend: "Smart Recommendations",
        refresh: "Refresh Data",
        random: "Random Roaming",
        addCurrent: "Add to Roaming",
        addFolder: "Add Folder",
        multiSelect: "Add Multiple Files",
        noDocuments: "No roaming documents yet",
        alreadyInRoaming: "Already in roaming",
        smartTooltip: "Jump to the most similar document"
      },
      nonRoaming: {
        title: "This document is not in your roaming list yet",
        description: "Add it to unlock custom metrics, priority tuning, and smart recommendations.",
        benefits: [
          "Set custom metric scores",
          "Fine-tune document priority",
          "Receive intelligent recommendations",
          "Appear in ranking insights"
        ],
        action: "Add to Roaming List"
      }
    },
    tabs: {
      metrics: "Document Metrics",
      ranking: "Priority Ranking",
      recommendations: "Smart Recommendations",
      visualization: "Priority Visualization"
    },
    metrics: {
      title: "Current Document Metrics",
      importance: "Importance",
      urgency: "Urgency",
      completion: "Completion",
      lastVisited: "Last Visited",
      visitCount: "Visit Count",
      totalScore: "Total Score",
      updateMetrics: "Update Metrics",
      noFileOpen: "No file is currently open",
      currentDocument: "Current Document",
      priorityLabel: "Priority",
      customMetricsTitle: "Custom Metrics",
      visitStatsTitle: "Visit Statistics",
      visitCountLabel: "Visit Count",
      lastVisitedLabel: "Last Visited",
      neverVisited: "Never visited",
      weightBreakdown: "Weight Breakdown",
      totalLabel: "Total"
    },
    ranking: {
      title: "Document Priority Ranking",
      emptyMessage: "No documents in roaming list",
      score: "Score",
      visits: "Visits",
      lastVisit: "Last Visit",
      priorityToggle: "By Priority",
      visitsToggle: "By Visits",
      refreshButton: "Refresh Ranking",
      openButton: "Open"
    },
    recommendations: {
      title: "Intelligent Document Recommendations",
      emptyMessage: "No recommendations available",
      similarity: "Similarity",
      openRecommended: "Open Recommended",
      refreshing: "Refreshing recommendations...",
      refreshButton: "Refresh Recommendations",
      smartJumpButton: "Jump to Top Match",
      smartJumpFailed: "Smart jump failed, please try again",
      smartJumpNotice: "Smart recommendation: {filename} (similarity {similarity}%)",
      priorityLabel: "Priority",
      visitCountLabel: "Visits",
      openButton: "Open"
    },
    visualization: {
      title: "Priority Visualization",
      xAxis: "Document Rank (by priority)",
      yAxis: "Priority Score",
      refresh: "Refresh",
      emptyMessage: "No documents to visualize"
    },
    actions: {
      addFile: "Add Current File",
      addFolder: "Add Folder",
      addMultiple: "Add Multiple Files",
      removeFromRoaming: "Remove from Roaming",
      clearHistory: "Clear History",
      refresh: "Refresh"
    },
    settings: {
      title: "Incremental Reading Settings",
      general: {
        title: "General Settings",
        language: "Language",
        languageDesc: "Select the interface language"
      },
      customMetrics: {
        title: "Custom Metrics",
        description: "Define your own evaluation metrics (1-10 indicators). Weights are automatically normalized.",
        addMetric: "Add Metric",
        metricName: "Metric Name",
        metricWeight: "Weight",
        removeMetric: "Remove",
        minMetricsWarning: "At least one metric is required",
        maxMetricsWarning: "Maximum 10 metrics allowed"
      },
      recommendation: {
        title: "Recommendation Settings",
        description: "Configure intelligent recommendation algorithm parameters",
        recentCount: "Recent Documents Count",
        recentCountDesc: "Number of recently visited documents to use as reference",
        topCount: "Top Priority Count",
        topCountDesc: "Number of high-priority documents to use as reference",
        topK: "Recommendation Count",
        topKDesc: "Number of recommendations to display",
        maxCandidates: "Max Candidates",
        maxCandidatesDesc: "Maximum number of documents to analyze",
        maxParagraphs: "Max Paragraphs",
        maxParagraphsDesc: "Maximum paragraphs to analyze per document"
      },
      filter: {
        title: "Filter Settings",
        description: "Configure document filtering rules",
        excludeVisited: "Exclude Visited Documents",
        excludeVisitedDesc: "Do not recommend documents you've already visited",
        excludedPaths: "Excluded Paths",
        excludedPathsDesc: "Path patterns to exclude (one per line, supports wildcards)",
        excludedPathsPlaceholder: "Templates/**\nArchive/**"
      },
      dataManagement: {
        title: "Data Management",
        description: "Manage your reading history and settings data",
        clearHistory: "Clear Reading History",
        clearHistoryDesc: "Remove all documents from roaming list and reset visit counts",
        clearButton: "Clear History",
        clearConfirm: "Are you sure you want to clear all reading history?",
        exportData: "Export Data",
        exportDataDesc: "Export all settings and metrics to a JSON file",
        exportButton: "Export",
        importData: "Import Data",
        importDataDesc: "Import settings and metrics from a JSON file",
        importButton: "Import"
      }
    },
    notices: {
      addedToRoaming: 'Added "{filename}" to roaming',
      removedFromRoaming: 'Removed "{filename}" from roaming',
      historyCleared: "Reading history cleared",
      onlyMarkdownFiles: "Only Markdown files can be added to roaming list",
      noActiveFile: "No active file",
      filesAdded: "Successfully added {count} files to roaming list",
      noFilesAdded: "No files were added",
      settingsSaved: "Settings saved",
      errorSavingSettings: "Error saving settings",
      errorLoadingSettings: "Error loading settings, using defaults",
      dataExported: "Data exported successfully",
      dataImported: "Data imported successfully",
      invalidData: "Invalid data format",
      continueFailed: "Continue reading failed",
      randomRoaming: "\u{1F3B2} Random roaming: {filename}",
      randomRoamingFailed: "Random roaming failed",
      selectionProbability: "Selected: {filename} (probability: {probability}%)",
      documentOpenFailed: "Failed to open document",
      editMetricsFailed: "Failed to edit document metrics",
      fileSwitchError: "Error switching files",
      smartRecommendationFailed: "Smart recommendation failed, please try again"
    },
    commands: {
      startReading: "Start Incremental Reading",
      openRandom: "Open Random Document",
      addToRoaming: "Add to Roaming",
      addFolder: "Add Folder to Roaming",
      addMultiple: "Add Multiple Files to Roaming",
      clearHistory: "Clear Reading History"
    }
  },
  zh: {
    common: {
      ok: "\u786E\u5B9A",
      cancel: "\u53D6\u6D88",
      save: "\u4FDD\u5B58",
      delete: "\u5220\u9664",
      edit: "\u7F16\u8F91",
      add: "\u6DFB\u52A0",
      remove: "\u79FB\u9664",
      confirm: "\u786E\u8BA4",
      close: "\u5173\u95ED",
      reset: "\u91CD\u7F6E",
      search: "\u641C\u7D22",
      loading: "\u52A0\u8F7D\u4E2D...",
      error: "\u9519\u8BEF",
      success: "\u6210\u529F",
      warning: "\u8B66\u544A"
    },
    view: {
      title: "\u6F2B\u6E38\u5F0F\u6E10\u8FDB\u9605\u8BFB",
      subtitle: '"\u5C55\u5377\u4E43\u65E0\u8A00\u7684\u60C5\u610F\uFF1A\u4EE5<span class="chance">\u7B49\u5F85\u6F2B\u6E38...</span>\u7684\u673A\u9047\uFF0C<br>\u7A7F\u8D8A\u661F\u8FB0\u9047\u89C1\u4F60\uFF0C\u4E09\u79CB\u971C\u96EA\u5370\u9A6C\u8E44\u3002"',
      statusTemplate: "\u5DF2\u6F2B\u6E38 {count} \u4E2A\u6587\u6863",
      noDocuments: "\u6F2B\u6E38\u5217\u8868\u4E3A\u7A7A",
      openDocument: "\u6253\u5F00\u6587\u6863",
      actionBar: {
        continue: "\u7EE7\u7EED\u9605\u8BFB",
        smartRecommend: "\u667A\u80FD\u63A8\u8350",
        refresh: "\u5237\u65B0\u6570\u636E",
        random: "\u968F\u673A\u6F2B\u6E38",
        addCurrent: "\u52A0\u5165\u6F2B\u6E38",
        addFolder: "\u6DFB\u52A0\u6587\u4EF6\u5939",
        multiSelect: "\u6279\u91CF\u6DFB\u52A0",
        noDocuments: "\u6682\u65E0\u6F2B\u6E38\u6587\u6863",
        alreadyInRoaming: "\u5DF2\u5728\u6F2B\u6E38\u5217\u8868",
        smartTooltip: "\u8DF3\u8F6C\u5230\u6700\u76F8\u4F3C\u7684\u6587\u6863"
      },
      nonRoaming: {
        title: "\u6B64\u6587\u6863\u5C1A\u672A\u52A0\u5165\u6F2B\u6E38\u5217\u8868",
        description: "\u5C06\u5176\u6DFB\u52A0\u5230\u6F2B\u6E38\u5217\u8868\uFF0C\u89E3\u9501\u81EA\u5B9A\u4E49\u6307\u6807\u3001\u4F18\u5148\u7EA7\u8C03\u6574\u548C\u667A\u80FD\u63A8\u8350\u529F\u80FD\u3002",
        benefits: [
          "\u8BBE\u7F6E\u81EA\u5B9A\u4E49\u6307\u6807\u8BC4\u5206",
          "\u8C03\u6574\u6587\u6863\u4F18\u5148\u7EA7",
          "\u83B7\u5F97\u667A\u80FD\u63A8\u8350",
          "\u51FA\u73B0\u5728\u6392\u884C\u699C\u4E2D"
        ],
        action: "\u6DFB\u52A0\u5230\u6F2B\u6E38\u5217\u8868"
      }
    },
    tabs: {
      metrics: "\u6587\u6863\u6307\u6807",
      ranking: "\u4F18\u5148\u7EA7\u6392\u884C",
      recommendations: "\u667A\u80FD\u63A8\u8350",
      visualization: "\u4F18\u5148\u7EA7\u53EF\u89C6\u5316"
    },
    metrics: {
      title: "\u5F53\u524D\u6587\u6863\u6307\u6807",
      importance: "\u91CD\u8981\u6027",
      urgency: "\u7D27\u6025\u5EA6",
      completion: "\u5B8C\u6210\u5EA6",
      lastVisited: "\u6700\u540E\u8BBF\u95EE",
      visitCount: "\u8BBF\u95EE\u6B21\u6570",
      totalScore: "\u7EFC\u5408\u8BC4\u5206",
      updateMetrics: "\u66F4\u65B0\u6307\u6807",
      noFileOpen: "\u5F53\u524D\u6CA1\u6709\u6253\u5F00\u7684\u6587\u4EF6",
      currentDocument: "\u5F53\u524D\u6587\u6863",
      priorityLabel: "\u4F18\u5148\u7EA7",
      customMetricsTitle: "\u81EA\u5B9A\u4E49\u6307\u6807",
      visitStatsTitle: "\u8BBF\u95EE\u7EDF\u8BA1",
      visitCountLabel: "\u8BBF\u95EE\u6B21\u6570",
      lastVisitedLabel: "\u6700\u540E\u8BBF\u95EE",
      neverVisited: "\u4ECE\u672A\u8BBF\u95EE",
      weightBreakdown: "\u6743\u91CD\u5206\u89E3",
      totalLabel: "\u603B\u8BA1"
    },
    ranking: {
      title: "\u6587\u6863\u4F18\u5148\u7EA7\u6392\u884C",
      emptyMessage: "\u6F2B\u6E38\u5217\u8868\u4E3A\u7A7A",
      score: "\u8BC4\u5206",
      visits: "\u8BBF\u95EE",
      lastVisit: "\u6700\u540E\u8BBF\u95EE",
      priorityToggle: "\u6309\u4F18\u5148\u7EA7",
      visitsToggle: "\u6309\u8BBF\u95EE\u91CF",
      refreshButton: "\u5237\u65B0\u6392\u884C",
      openButton: "\u6253\u5F00"
    },
    recommendations: {
      title: "\u667A\u80FD\u6587\u6863\u63A8\u8350",
      emptyMessage: "\u6682\u65E0\u63A8\u8350",
      similarity: "\u76F8\u4F3C\u5EA6",
      openRecommended: "\u6253\u5F00\u63A8\u8350",
      refreshing: "\u6B63\u5728\u5237\u65B0\u63A8\u8350...",
      refreshButton: "\u5237\u65B0\u63A8\u8350",
      smartJumpButton: "\u8DF3\u8F6C\u5230\u6700\u4F73\u5339\u914D",
      smartJumpFailed: "\u667A\u80FD\u8DF3\u8F6C\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
      smartJumpNotice: "\u667A\u80FD\u63A8\u8350\uFF1A{filename}\uFF08\u76F8\u4F3C\u5EA6 {similarity}%\uFF09",
      priorityLabel: "\u4F18\u5148\u7EA7",
      visitCountLabel: "\u8BBF\u95EE\u91CF",
      openButton: "\u6253\u5F00"
    },
    visualization: {
      title: "\u4F18\u5148\u7EA7\u53EF\u89C6\u5316",
      xAxis: "\u6587\u6863\u6392\u540D\uFF08\u6309\u4F18\u5148\u7EA7\uFF09",
      yAxis: "\u4F18\u5148\u7EA7\u5206\u6570",
      refresh: "\u5237\u65B0",
      emptyMessage: "\u6CA1\u6709\u53EF\u89C6\u5316\u7684\u6587\u6863"
    },
    actions: {
      addFile: "\u52A0\u5165\u5F53\u524D\u6587\u6863",
      addFolder: "\u6DFB\u52A0\u6587\u4EF6\u5939",
      addMultiple: "\u6279\u91CF\u6DFB\u52A0",
      removeFromRoaming: "\u79FB\u51FA\u6F2B\u6E38",
      clearHistory: "\u6E05\u9664\u5386\u53F2",
      refresh: "\u5237\u65B0"
    },
    settings: {
      title: "\u589E\u91CF\u9605\u8BFB \u63D2\u4EF6\u8BBE\u7F6E",
      general: {
        title: "\u901A\u7528\u8BBE\u7F6E",
        language: "\u754C\u9762\u8BED\u8A00",
        languageDesc: "\u9009\u62E9\u754C\u9762\u663E\u793A\u8BED\u8A00"
      },
      customMetrics: {
        title: "\u81EA\u5B9A\u4E49\u6307\u6807",
        description: "\u81EA\u5B9A\u4E49\u8BC4\u4F30\u6307\u6807\uFF081-10\u4E2A\uFF09\uFF0C\u6743\u91CD\u4F1A\u81EA\u52A8\u6807\u51C6\u5316",
        addMetric: "\u6DFB\u52A0\u6307\u6807",
        metricName: "\u6307\u6807\u540D\u79F0",
        metricWeight: "\u6743\u91CD",
        removeMetric: "\u5220\u9664",
        minMetricsWarning: "\u81F3\u5C11\u9700\u8981\u4E00\u4E2A\u6307\u6807",
        maxMetricsWarning: "\u6700\u591A\u53EA\u80FD\u6DFB\u52A010\u4E2A\u6307\u6807"
      },
      recommendation: {
        title: "\u63A8\u8350\u8BBE\u7F6E",
        description: "\u914D\u7F6E\u667A\u80FD\u63A8\u8350\u7B97\u6CD5\u53C2\u6570",
        recentCount: "\u6700\u8FD1\u6587\u6863\u6570",
        recentCountDesc: "\u7528\u4F5C\u53C2\u8003\u7684\u6700\u8FD1\u8BBF\u95EE\u6587\u6863\u6570\u91CF",
        topCount: "\u9AD8\u4F18\u5148\u7EA7\u6587\u6863\u6570",
        topCountDesc: "\u7528\u4F5C\u53C2\u8003\u7684\u9AD8\u4F18\u5148\u7EA7\u6587\u6863\u6570\u91CF",
        topK: "\u63A8\u8350\u6570\u91CF",
        topKDesc: "\u663E\u793A\u7684\u63A8\u8350\u6587\u6863\u6570\u91CF",
        maxCandidates: "\u6700\u5927\u5019\u9009\u6570",
        maxCandidatesDesc: "\u5206\u6790\u7684\u6700\u5927\u6587\u6863\u6570\u91CF",
        maxParagraphs: "\u6700\u5927\u6BB5\u843D\u6570",
        maxParagraphsDesc: "\u6BCF\u4E2A\u6587\u6863\u5206\u6790\u7684\u6700\u5927\u6BB5\u843D\u6570"
      },
      filter: {
        title: "\u8FC7\u6EE4\u8BBE\u7F6E",
        description: "\u914D\u7F6E\u6587\u6863\u8FC7\u6EE4\u89C4\u5219",
        excludeVisited: "\u6392\u9664\u5DF2\u8BBF\u95EE\u6587\u6863",
        excludeVisitedDesc: "\u4E0D\u63A8\u8350\u5DF2\u7ECF\u8BBF\u95EE\u8FC7\u7684\u6587\u6863",
        excludedPaths: "\u6392\u9664\u8DEF\u5F84",
        excludedPathsDesc: "\u8981\u6392\u9664\u7684\u8DEF\u5F84\u6A21\u5F0F\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF0C\u652F\u6301\u901A\u914D\u7B26\uFF09",
        excludedPathsPlaceholder: "Templates/**\nArchive/**"
      },
      dataManagement: {
        title: "\u6570\u636E\u7BA1\u7406",
        description: "\u7BA1\u7406\u4F60\u7684\u9605\u8BFB\u5386\u53F2\u548C\u8BBE\u7F6E\u6570\u636E",
        clearHistory: "\u6E05\u9664\u9605\u8BFB\u5386\u53F2",
        clearHistoryDesc: "\u4ECE\u6F2B\u6E38\u5217\u8868\u4E2D\u79FB\u9664\u6240\u6709\u6587\u6863\u5E76\u91CD\u7F6E\u8BBF\u95EE\u8BA1\u6570",
        clearButton: "\u6E05\u9664\u5386\u53F2",
        clearConfirm: "\u786E\u5B9A\u8981\u6E05\u9664\u6240\u6709\u9605\u8BFB\u5386\u53F2\u5417\uFF1F",
        exportData: "\u5BFC\u51FA\u6570\u636E",
        exportDataDesc: "\u5C06\u6240\u6709\u8BBE\u7F6E\u548C\u6307\u6807\u5BFC\u51FA\u5230JSON\u6587\u4EF6",
        exportButton: "\u5BFC\u51FA",
        importData: "\u5BFC\u5165\u6570\u636E",
        importDataDesc: "\u4ECEJSON\u6587\u4EF6\u5BFC\u5165\u8BBE\u7F6E\u548C\u6307\u6807",
        importButton: "\u5BFC\u5165"
      }
    },
    notices: {
      addedToRoaming: '\u5DF2\u5C06 "{filename}" \u52A0\u5165\u6F2B\u6E38',
      removedFromRoaming: '\u5DF2\u5C06 "{filename}" \u79FB\u51FA\u6F2B\u6E38',
      historyCleared: "\u9605\u8BFB\u5386\u53F2\u5DF2\u6E05\u9664",
      onlyMarkdownFiles: "\u53EA\u80FD\u6DFB\u52A0Markdown\u6587\u6863\u5230\u6F2B\u6E38\u5217\u8868",
      noActiveFile: "\u6CA1\u6709\u6253\u5F00\u7684\u6587\u6863",
      filesAdded: "\u6210\u529F\u6DFB\u52A0 {count} \u4E2A\u6587\u4EF6\u5230\u6F2B\u6E38\u5217\u8868",
      noFilesAdded: "\u6CA1\u6709\u6587\u4EF6\u88AB\u6DFB\u52A0",
      settingsSaved: "\u8BBE\u7F6E\u5DF2\u4FDD\u5B58",
      errorSavingSettings: "\u4FDD\u5B58\u8BBE\u7F6E\u65F6\u51FA\u9519",
      errorLoadingSettings: "\u52A0\u8F7D\u8BBE\u7F6E\u65F6\u51FA\u9519\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u8BBE\u7F6E",
      dataExported: "\u6570\u636E\u5BFC\u51FA\u6210\u529F",
      dataImported: "\u6570\u636E\u5BFC\u5165\u6210\u529F",
      invalidData: "\u65E0\u6548\u7684\u6570\u636E\u683C\u5F0F",
      continueFailed: "\u7EE7\u7EED\u6F2B\u6E38\u5931\u8D25",
      randomRoaming: "\u{1F3B2} \u968F\u673A\u6F2B\u6E38\uFF1A{filename}",
      randomRoamingFailed: "\u968F\u673A\u6F2B\u6E38\u5931\u8D25",
      selectionProbability: "\u5DF2\u9009\u62E9\uFF1A{filename}\uFF08\u9009\u62E9\u6982\u7387\uFF1A{probability}%\uFF09",
      documentOpenFailed: "\u6253\u5F00\u6587\u6863\u5931\u8D25",
      editMetricsFailed: "\u7F16\u8F91\u6587\u6863\u5F97\u5206\u5931\u8D25",
      fileSwitchError: "\u6587\u4EF6\u5207\u6362\u65F6\u51FA\u73B0\u9519\u8BEF",
      smartRecommendationFailed: "\u667A\u80FD\u63A8\u8350\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5"
    },
    commands: {
      startReading: "\u5F00\u59CB\u589E\u91CF\u9605\u8BFB",
      openRandom: "\u6253\u5F00\u968F\u673A\u6587\u6863",
      addToRoaming: "\u6DFB\u52A0\u81F3\u6F2B\u6E38",
      addFolder: "\u6DFB\u52A0\u6587\u4EF6\u5939\u5230\u6F2B\u6E38",
      addMultiple: "\u6279\u91CF\u6DFB\u52A0\u6587\u4EF6\u5230\u6F2B\u6E38",
      clearHistory: "\u6E05\u9664\u9605\u8BFB\u5386\u53F2"
    }
  }
};

// src/i18n/i18n.ts
var I18n = class {
  constructor() {
    this.currentLanguage = "en";
    this.translations = translations;
  }
  static getInstance() {
    if (!I18n.instance) {
      I18n.instance = new I18n();
    }
    return I18n.instance;
  }
  setLanguage(language) {
    if (this.translations[language]) {
      this.currentLanguage = language;
    } else {
      console.warn(`Language ${language} not found, falling back to English`);
      this.currentLanguage = "en";
    }
  }
  getLanguage() {
    return this.currentLanguage;
  }
  t(key, replacements) {
    const keys = key.split(".");
    let value = this.translations[this.currentLanguage];
    for (const k of keys) {
      if (value && typeof value === "object" && k in value) {
        value = value[k];
      } else {
        console.warn(`Translation key not found: ${key}`);
        return key;
      }
    }
    if (typeof value !== "string") {
      console.warn(`Translation value is not a string: ${key}`);
      return key;
    }
    if (replacements) {
      Object.keys(replacements).forEach((replaceKey) => {
        value = value.replace(new RegExp(`\\{${replaceKey}\\}`, "g"), String(replacements[replaceKey]));
      });
    }
    return value;
  }
  // Convenience method to get the entire translation object
  getTranslation() {
    return this.translations[this.currentLanguage];
  }
  // Get localized metric name
  getMetricName(metric) {
    var _a, _b;
    const lang = this.currentLanguage;
    if (metric.name && metric.name[lang]) {
      return metric.name[lang];
    }
    return ((_a = metric.name) == null ? void 0 : _a.en) || ((_b = metric.name) == null ? void 0 : _b.zh) || "Unknown";
  }
  // Get available languages
  getAvailableLanguages() {
    return [
      { code: "en", name: "English" },
      { code: "zh", name: "\u4E2D\u6587" }
    ];
  }
};
var i18n = I18n.getInstance();

// src/components/Modal.ts
var DocumentMetricsModal = class extends import_obsidian.Modal {
  constructor(app, file, metrics, customMetrics, onSave, onRealTimeUpdate) {
    super(app);
    // Real-time update callback
    this.sliders = /* @__PURE__ */ new Map();
    this.valueDisplays = /* @__PURE__ */ new Map();
    this.isProcessing = false;
    this.file = file;
    this.initialMetrics = { ...metrics };
    this.customMetrics = customMetrics;
    this.onSave = onSave;
    this.onRealTimeUpdate = onRealTimeUpdate;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("incremental-reading-plugin-root");
    contentEl.addClass("incremental-reading-modal", "document-metrics-modal");
    contentEl.createEl("h2", {
      text: `\u8C03\u6574\u6587\u6863\u5F97\u5206: ${this.file.basename || "\u672A\u77E5\u6587\u6863"}`
    });
    const sliderContainer = contentEl.createEl("div", { cls: "sliders-container" });
    for (const metric of this.customMetrics) {
      const config = {
        key: metric.id,
        label: `${i18n.getMetricName(metric)} (${metric.weight}%)`,
        min: 0,
        max: 10,
        step: 0.5
      };
      const sliderGroup = sliderContainer.createEl("div", { cls: "slider-group" });
      const labelRow = sliderGroup.createEl("div", { cls: "label-row" });
      labelRow.createEl("label", {
        text: config.label,
        cls: "metric-label"
      });
      const valueDisplay = labelRow.createEl("span", {
        text: (this.initialMetrics[config.key] || 5).toFixed(1),
        cls: "value-display"
      });
      this.valueDisplays.set(config.key, valueDisplay);
      const slider = sliderGroup.createEl("input", {
        type: "range",
        cls: "slider"
      });
      slider.min = config.min.toString();
      slider.max = config.max.toString();
      slider.step = config.step.toString();
      slider.value = (this.initialMetrics[config.key] || 5).toString();
      this.sliders.set(config.key, slider);
      slider.addEventListener("input", async () => {
        const value = parseFloat(slider.value);
        valueDisplay.textContent = value.toFixed(1);
        if (this.onRealTimeUpdate) {
          const currentMetrics = { ...this.initialMetrics };
          for (const [key, sliderElement] of this.sliders) {
            currentMetrics[key] = parseFloat(sliderElement.value);
          }
          try {
            await this.onRealTimeUpdate(currentMetrics);
          } catch (error) {
            console.warn("Real-time update failed:", error);
          }
        }
      });
    }
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u4FDD\u5B58",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88",
      cls: "mod-cancel"
    });
    confirmBtn.onclick = async () => {
      if (this.isProcessing)
        return;
      try {
        this.isProcessing = true;
        confirmBtn.textContent = "\u4FDD\u5B58\u4E2D...";
        confirmBtn.disabled = true;
        cancelBtn.disabled = true;
        const updatedMetrics = { ...this.initialMetrics };
        for (const [key, slider] of this.sliders) {
          updatedMetrics[key] = parseFloat(slider.value);
        }
        await this.onSave(updatedMetrics);
        this.close();
      } catch (error) {
        console.error("\u4FDD\u5B58\u6587\u6863\u5F97\u5206\u5931\u8D25:", error);
        new import_obsidian.Notice("\u4FDD\u5B58\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
        confirmBtn.textContent = "\u4FDD\u5B58";
        confirmBtn.disabled = false;
        cancelBtn.disabled = false;
      } finally {
        this.isProcessing = false;
      }
    };
    cancelBtn.onclick = () => this.close();
    this.scope.register([], "Enter", () => confirmBtn.click());
    this.scope.register([], "Escape", () => cancelBtn.click());
    setTimeout(() => {
      var _a;
      return (_a = this.sliders.values().next().value) == null ? void 0 : _a.focus();
    }, 100);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.removeClass("incremental-reading-modal", "document-metrics-modal");
  }
};
var FolderSelectionModal = class extends import_obsidian.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.folderList = null;
    this.selectedFolders = /* @__PURE__ */ new Set();
    this.isProcessing = false;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("incremental-reading-plugin-root");
    contentEl.addClass("incremental-reading-modal", "folder-selection-modal");
    contentEl.createEl("h2", { text: "\u9009\u62E9\u6587\u4EF6\u5939" });
    contentEl.createEl("p", {
      text: "\u9009\u62E9\u8981\u6DFB\u52A0\u5230\u6F2B\u6E38\u5217\u8868\u7684\u6587\u4EF6\u5939\uFF08\u9012\u5F52\u5305\u542B\u6240\u6709Markdown\u6587\u4EF6\uFF09",
      cls: "instruction-text"
    });
    const listContainer = contentEl.createEl("div", { cls: "folder-list-container" });
    this.folderList = listContainer.createEl("div", { cls: "folder-list" });
    this.populateFolderList();
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6\u5939",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88",
      cls: "mod-cancel"
    });
    confirmBtn.onclick = async () => {
      if (this.isProcessing)
        return;
      try {
        this.isProcessing = true;
        confirmBtn.textContent = "\u6DFB\u52A0\u4E2D...";
        confirmBtn.disabled = true;
        cancelBtn.disabled = true;
        await this.onConfirm(Array.from(this.selectedFolders));
        this.close();
      } catch (error) {
        console.error("\u6DFB\u52A0\u6587\u4EF6\u5939\u5931\u8D25:", error);
        new import_obsidian.Notice("\u6DFB\u52A0\u6587\u4EF6\u5939\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
        confirmBtn.textContent = "\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6\u5939";
        confirmBtn.disabled = false;
        cancelBtn.disabled = false;
      } finally {
        this.isProcessing = false;
      }
    };
    cancelBtn.onclick = () => this.close();
    this.scope.register([], "Escape", () => cancelBtn.click());
  }
  populateFolderList() {
    if (!this.folderList)
      return;
    this.folderList.empty();
    const files = this.app.vault.getAllLoadedFiles();
    const folders = files.filter((file) => file instanceof import_obsidian.TFolder);
    folders.sort((a, b) => a.path.localeCompare(b.path));
    folders.forEach((folder) => {
      const folderItem = this.folderList.createEl("div", { cls: "folder-item" });
      const checkbox = folderItem.createEl("input", {
        type: "checkbox",
        cls: "folder-checkbox"
      });
      const label = folderItem.createEl("label", {
        text: folder.path || "(\u6839\u76EE\u5F55)",
        cls: "folder-label"
      });
      folderItem.onclick = (e) => {
        if (e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
        }
        this.toggleFolder(folder.path, checkbox.checked);
      };
      checkbox.onchange = () => {
        this.toggleFolder(folder.path, checkbox.checked);
      };
    });
  }
  toggleFolder(folderPath, selected) {
    if (selected) {
      this.selectedFolders.add(folderPath);
    } else {
      this.selectedFolders.delete(folderPath);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.removeClass("incremental-reading-modal", "folder-selection-modal");
  }
};
var MultiFileSelectionModal = class extends import_obsidian.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.fileList = null;
    this.selectedFiles = /* @__PURE__ */ new Set();
    this.availableFiles = [];
    this.isProcessing = false;
    this.searchInput = null;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("incremental-reading-plugin-root");
    contentEl.addClass("incremental-reading-modal", "multi-file-selection-modal");
    contentEl.createEl("h2", { text: "\u591A\u9009\u6587\u4EF6" });
    contentEl.createEl("p", {
      text: "\u9009\u62E9\u8981\u6DFB\u52A0\u5230\u6F2B\u6E38\u5217\u8868\u7684Markdown\u6587\u4EF6\uFF08\u652F\u6301Ctrl+\u70B9\u51FB\u591A\u9009\uFF09",
      cls: "instruction-text"
    });
    const searchContainer = contentEl.createEl("div", { cls: "search-container" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u641C\u7D22\u6587\u4EF6...",
      cls: "search-input"
    });
    this.searchInput.addEventListener("input", () => this.filterFiles());
    const listContainer = contentEl.createEl("div", { cls: "file-list-container" });
    this.fileList = listContainer.createEl("div", { cls: "file-list" });
    this.populateFileList();
    const selectionInfo = contentEl.createEl("div", { cls: "selection-info" });
    selectionInfo.textContent = "\u5DF2\u9009\u62E9 0 \u4E2A\u6587\u4EF6";
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88",
      cls: "mod-cancel"
    });
    confirmBtn.onclick = async () => {
      if (this.isProcessing)
        return;
      try {
        this.isProcessing = true;
        confirmBtn.textContent = "\u6DFB\u52A0\u4E2D...";
        confirmBtn.disabled = true;
        cancelBtn.disabled = true;
        const selectedFileObjects = this.availableFiles.filter(
          (file) => this.selectedFiles.has(file.path)
        );
        await this.onConfirm(selectedFileObjects);
        this.close();
      } catch (error) {
        console.error("\u6DFB\u52A0\u6587\u4EF6\u5931\u8D25:", error);
        new import_obsidian.Notice("\u6DFB\u52A0\u6587\u4EF6\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
        confirmBtn.textContent = "\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6";
        confirmBtn.disabled = false;
        cancelBtn.disabled = false;
      } finally {
        this.isProcessing = false;
      }
    };
    cancelBtn.onclick = () => this.close();
    this.updateSelectionInfo = this.updateSelectionInfo.bind(this, selectionInfo);
    this.scope.register([], "Escape", () => cancelBtn.click());
    setTimeout(() => {
      var _a;
      return (_a = this.searchInput) == null ? void 0 : _a.focus();
    }, 100);
  }
  populateFileList() {
    if (!this.fileList)
      return;
    this.fileList.empty();
    this.availableFiles = this.app.vault.getMarkdownFiles();
    this.availableFiles.sort((a, b) => a.path.localeCompare(b.path));
    this.availableFiles.forEach((file) => {
      const fileItem = this.fileList.createEl("div", { cls: "file-item" });
      const checkbox = fileItem.createEl("input", {
        type: "checkbox",
        cls: "file-checkbox"
      });
      const label = fileItem.createEl("label", {
        text: file.path,
        cls: "file-label"
      });
      fileItem.onclick = (e) => {
        if (e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
        }
        this.toggleFile(file.path, checkbox.checked);
      };
      checkbox.onchange = () => {
        this.toggleFile(file.path, checkbox.checked);
      };
    });
  }
  toggleFile(filePath, selected) {
    if (selected) {
      this.selectedFiles.add(filePath);
    } else {
      this.selectedFiles.delete(filePath);
    }
    this.updateSelectionInfo(document.querySelector(".selection-info"));
  }
  updateSelectionInfo(selectionInfo) {
    selectionInfo.textContent = `\u5DF2\u9009\u62E9 ${this.selectedFiles.size} \u4E2A\u6587\u4EF6`;
  }
  filterFiles() {
    if (!this.searchInput || !this.fileList)
      return;
    const searchTerm = this.searchInput.value.toLowerCase();
    const fileItems = this.fileList.querySelectorAll(".file-item");
    fileItems.forEach((item, index) => {
      const file = this.availableFiles[index];
      const matchesSearch = file.path.toLowerCase().includes(searchTerm);
      item.style.display = matchesSearch ? "block" : "none";
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.removeClass("incremental-reading-modal", "multi-file-selection-modal");
  }
};

// src/views/components/ActionBar.ts
var ActionBar = class {
  constructor(container, plugin, callbacks) {
    this.continueBtn = null;
    this.addRoamingBtn = null;
    this.removeRoamingBtn = null;
    this.container = container;
    this.plugin = plugin;
    this.onContinueReading = callbacks.onContinueReading;
    this.onGetSmartRecommendations = callbacks.onGetSmartRecommendations;
    this.onRefreshData = callbacks.onRefreshData;
    this.onRandomRoaming = callbacks.onRandomRoaming;
    this.onAddCurrentToRoaming = callbacks.onAddCurrentToRoaming;
    this.onRemoveCurrentFromRoaming = callbacks.onRemoveCurrentFromRoaming;
    this.create();
  }
  create() {
    const actionBar = this.container.createEl("div", { cls: "action-bar" });
    this.continueBtn = actionBar.createEl("button", { cls: "btn primary" });
    this.continueBtn.textContent = i18n.t("view.actionBar.continue");
    this.continueBtn.onclick = () => this.onContinueReading();
    this.updateContinueButtonState();
    const recommendBtn = actionBar.createEl("button", { cls: "btn" });
    recommendBtn.textContent = i18n.t("view.actionBar.smartRecommend");
    recommendBtn.title = i18n.t("view.actionBar.smartTooltip");
    recommendBtn.onclick = () => this.onGetSmartRecommendations();
    const refreshDataBtn = actionBar.createEl("button", { cls: "btn" });
    refreshDataBtn.textContent = i18n.t("view.actionBar.refresh");
    refreshDataBtn.onclick = () => this.onRefreshData();
    const randomRoamBtn = actionBar.createEl("button", { cls: "btn" });
    randomRoamBtn.textContent = i18n.t("view.actionBar.random");
    randomRoamBtn.onclick = () => this.onRandomRoaming();
    this.addRoamingBtn = actionBar.createEl("button", { cls: "btn" });
    this.addRoamingBtn.textContent = i18n.t("view.actionBar.addCurrent");
    this.addRoamingBtn.onclick = () => this.onAddCurrentToRoaming();
    this.updateAddRoamingButtonState();
    this.removeRoamingBtn = actionBar.createEl("button", { cls: "btn" });
    this.removeRoamingBtn.textContent = i18n.t("actions.removeFromRoaming");
    this.removeRoamingBtn.onclick = () => this.onRemoveCurrentFromRoaming();
    this.updateRemoveRoamingButtonState();
    const addFolderBtn = actionBar.createEl("button", { cls: "btn primary" });
    addFolderBtn.textContent = i18n.t("view.actionBar.addFolder");
    addFolderBtn.onclick = () => this.addFolderToRoaming();
    const multiSelectBtn = actionBar.createEl("button", { cls: "btn primary" });
    multiSelectBtn.textContent = i18n.t("view.actionBar.multiSelect");
    multiSelectBtn.onclick = () => this.multiSelectFilesToRoaming();
  }
  addFolderToRoaming() {
    const folderModal = new FolderSelectionModal(this.plugin.app, async (folderPaths) => {
      await this.plugin.addFoldersToRoaming(folderPaths);
      this.onRefreshData();
    });
    folderModal.open();
  }
  multiSelectFilesToRoaming() {
    const fileModal = new MultiFileSelectionModal(this.plugin.app, async (files) => {
      await this.plugin.addMultipleFilesToRoaming(files);
      this.onRefreshData();
    });
    fileModal.open();
  }
  updateContinueButtonState() {
    if (!this.continueBtn)
      return;
    const validRoamingFiles = this.plugin.getValidRoamingFiles();
    const hasValidFiles = validRoamingFiles.length > 0;
    this.continueBtn.disabled = !hasValidFiles;
    this.continueBtn.textContent = hasValidFiles ? i18n.t("view.actionBar.continue") : i18n.t("view.actionBar.noDocuments");
  }
  updateAddRoamingButtonState() {
    if (!this.addRoamingBtn)
      return;
    const activeFile = this.plugin.app.workspace.getActiveFile();
    const isInRoaming = activeFile && this.plugin.settings.roamingDocs.includes(activeFile.path);
    if (isInRoaming) {
      this.addRoamingBtn.style.display = "none";
    } else {
      this.addRoamingBtn.style.display = "flex";
      this.addRoamingBtn.disabled = !activeFile;
      this.addRoamingBtn.textContent = activeFile ? i18n.t("view.actionBar.addCurrent") : i18n.t("view.actionBar.noDocuments");
    }
  }
  updateRemoveRoamingButtonState() {
    if (!this.removeRoamingBtn)
      return;
    const activeFile = this.plugin.app.workspace.getActiveFile();
    const isInRoaming = activeFile && this.plugin.settings.roamingDocs.includes(activeFile.path);
    if (isInRoaming) {
      this.removeRoamingBtn.style.display = "flex";
      this.removeRoamingBtn.disabled = false;
      this.removeRoamingBtn.textContent = i18n.t("actions.removeFromRoaming");
    } else {
      this.removeRoamingBtn.style.display = "none";
    }
  }
  /**
   * 更新按钮状态（当文件变化时调用）
   */
  updateButtonStates() {
    this.updateContinueButtonState();
    this.updateAddRoamingButtonState();
    this.updateRemoveRoamingButtonState();
  }
};

// src/views/components/DocumentMetrics.ts
var import_obsidian2 = require("obsidian");

// src/utils/SharedUtils.ts
var SharedUtils = class {
  /**
   * Calculate priority score for a document based on custom metrics and weights
   */
  static calculatePriority(metrics, weights, customMetrics) {
    let totalScore = 0;
    let totalWeight = 0;
    for (const metric of customMetrics) {
      const metricValue = metrics[metric.id] || 0;
      const metricWeight = weights[metric.id] || metric.weight;
      totalScore += metricValue * (metricWeight / 100);
      totalWeight += metricWeight / 100;
    }
    return totalWeight > 0 ? totalScore / totalWeight * 10 : 0;
  }
  /**
   * Safely get document metrics with defaults for custom metrics
   */
  static getDocumentMetrics(file, settings) {
    const filePath = file.path;
    const stored = settings.documentMetrics[filePath];
    if (stored) {
      return stored;
    }
    const defaultMetrics = {
      lastVisited: 0,
      visitCount: 0
    };
    for (const metric of settings.customMetrics) {
      defaultMetrics[metric.id] = 5;
    }
    return defaultMetrics;
  }
  /**
   * Update document metrics with validation
   */
  static updateDocumentMetrics(file, settings, metrics) {
    const filePath = file.path;
    const currentMetrics = this.getDocumentMetrics(file, settings);
    const updatedMetrics = {
      ...currentMetrics,
      ...metrics,
      lastVisited: Date.now()
    };
    const hasMetricUpdate = Object.keys(metrics).some(
      (key) => key !== "lastVisited" && key !== "visitCount" && metrics[key] !== void 0
    );
    if (hasMetricUpdate) {
      updatedMetrics.visitCount = currentMetrics.visitCount + 1;
    }
    return updatedMetrics;
  }
  /**
   * Check if file should be included based on excluded paths
   */
  static shouldIncludeFile(file, excludedPaths) {
    try {
      const excludedPatterns = excludedPaths.map(
        (pattern) => new RegExp(pattern.replace(/\*/g, ".*"), "i")
      );
      return !excludedPatterns.some((pattern) => pattern.test(file.path));
    } catch (error) {
      console.warn("Invalid regex pattern in excluded paths:", error);
      return true;
    }
  }
  /**
   * Get priority color based on score
   */
  static getPriorityColor(priority) {
    if (priority >= 8)
      return "#dc3545";
    if (priority >= 6)
      return "#fd7e14";
    if (priority >= 4)
      return "#ffc107";
    if (priority >= 2)
      return "#28a745";
    return "#6c757d";
  }
  /**
   * Safe JSON stringify with error handling
   */
  static safeStringify(obj) {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (error) {
      console.error("Error stringifying object:", error);
      return "{}";
    }
  }
  /**
   * Safe JSON parse with error handling
   */
  static safeParse(json, defaultValue) {
    try {
      return JSON.parse(json);
    } catch (error) {
      console.error("Error parsing JSON:", error);
      return defaultValue;
    }
  }
  /**
   * Debounce function for performance optimization
   */
  static debounce(func, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  }
  /**
   * Validate metric values are within acceptable ranges for custom metrics
   */
  static validateMetrics(metrics, customMetrics) {
    const validated = {};
    for (const metric of customMetrics) {
      if (metrics[metric.id] !== void 0) {
        validated[metric.id] = Math.max(0, Math.min(10, Number(metrics[metric.id])));
      }
    }
    if (metrics.lastVisited !== void 0) {
      validated.lastVisited = Math.max(0, Number(metrics.lastVisited));
    }
    if (metrics.visitCount !== void 0) {
      validated.visitCount = Math.max(0, Math.floor(Number(metrics.visitCount)));
    }
    return validated;
  }
  /**
   * Validate settings values
   */
  static validateSettings(settings) {
    const validated = {};
    if (!settings) {
      return validated;
    }
    if (settings.excludeVisited !== void 0) {
      validated.excludeVisited = Boolean(settings.excludeVisited);
    }
    const isNewUser = !settings.version || settings.version !== "2.0.0";
    if (settings.roamingDocs !== void 0) {
      validated.roamingDocs = Array.isArray(settings.roamingDocs) ? settings.roamingDocs.filter((path) => typeof path === "string") : [];
    } else {
      validated.roamingDocs = [];
    }
    if (isNewUser && settings.visitedDocs && Array.isArray(settings.visitedDocs) && settings.visitedDocs.length > 0) {
      console.log(`\u53D1\u73B0 ${settings.visitedDocs.length} \u4E2A\u5386\u53F2\u8BBF\u95EE\u8BB0\u5F55\uFF0C\u8BF7\u4F7F\u7528"\u6DFB\u52A0\u81F3\u6F2B\u6E38"\u529F\u80FD\u624B\u52A8\u6DFB\u52A0\u9700\u8981\u7684\u6587\u6863`);
    }
    if (settings.excludedPaths !== void 0) {
      validated.excludedPaths = Array.isArray(settings.excludedPaths) ? settings.excludedPaths.filter((path) => typeof path === "string") : [];
    }
    if (settings.maxCandidates !== void 0) {
      validated.maxCandidates = Math.max(10, Math.min(1e3, Number(settings.maxCandidates)));
    }
    if (settings.customMetrics !== void 0 && Array.isArray(settings.customMetrics)) {
      validated.customMetrics = settings.customMetrics.filter(
        (metric) => metric && typeof metric.id === "string" && (typeof metric.name === "string" || typeof metric.name === "object" && metric.name.en && metric.name.zh) && typeof metric.weight === "number"
      ).map((metric) => {
        let name;
        if (typeof metric.name === "string") {
          const chineseName = metric.name;
          const englishName = this.getEnglishTranslation(chineseName) || chineseName;
          name = { en: englishName, zh: chineseName };
        } else {
          name = metric.name;
        }
        return {
          id: metric.id,
          name,
          weight: Math.max(0, Math.min(100, metric.weight))
        };
      });
    } else {
      validated.customMetrics = [
        { id: "importance", name: { en: "Importance", zh: "\u91CD\u8981\u6027" }, weight: 40 },
        { id: "urgency", name: { en: "Urgency", zh: "\u7D27\u6025\u5EA6" }, weight: 30 },
        { id: "completion", name: { en: "Completion", zh: "\u5B8C\u6210\u5EA6" }, weight: 30 }
      ];
    }
    if (validated.customMetrics && validated.customMetrics.length > 0) {
      const totalWeight = validated.customMetrics.reduce((sum, metric) => sum + metric.weight, 0);
      if (totalWeight > 0) {
        validated.customMetrics = validated.customMetrics.map((metric) => ({
          ...metric,
          weight: Math.round(metric.weight / totalWeight * 100)
        }));
      }
    }
    if (validated.customMetrics) {
      validated.metricWeights = {};
      for (const metric of validated.customMetrics) {
        validated.metricWeights[metric.id] = metric.weight;
      }
    }
    return validated;
  }
  /**
   * Create a safe element getter with null checks
   */
  static safeElementQuery(container, selector) {
    if (!container)
      return null;
    try {
      return container.querySelector(selector);
    } catch (error) {
      console.warn("Invalid selector:", selector, error);
      return null;
    }
  }
  /**
   * Generate a unique ID for DOM elements
   */
  static generateId(prefix = "ir") {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Format file size in human readable format
   */
  static formatFileSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  /**
   * Truncate text with ellipsis
   */
  static truncateText(text, maxLength) {
    if (text.length <= maxLength)
      return text;
    return text.substr(0, maxLength - 3) + "...";
  }
  /**
   * Check if a value is a valid number
   */
  static isValidNumber(value) {
    return typeof value === "number" && !isNaN(value) && isFinite(value);
  }
  /**
   * Get English translation for Chinese metric names
   */
  static getEnglishTranslation(chineseName) {
    const translations2 = {
      "\u91CD\u8981\u6027": "Importance",
      "\u7D27\u6025\u5EA6": "Urgency",
      "\u5B8C\u6210\u5EA6": "Completion",
      "\u96BE\u5EA6": "Difficulty",
      "\u5174\u8DA3\u5EA6": "Interest",
      "\u5B9E\u7528\u6027": "Practicality",
      "\u4F18\u5148\u7EA7": "Priority",
      "\u590D\u6742\u5EA6": "Complexity",
      "\u4EF7\u503C\u5EA6": "Value",
      "\u65F6\u6548\u6027": "Timeliness"
    };
    return translations2[chineseName] || null;
  }
};

// src/views/components/DocumentMetrics.ts
var DocumentMetricsDisplay = class {
  constructor(container, plugin, file, metrics, onMetricsUpdated) {
    this.container = container;
    this.plugin = plugin;
    this.file = file;
    this.metrics = metrics;
    this.onMetricsUpdated = onMetricsUpdated || (() => {
    });
    console.log(`DocumentMetricsDisplay \u521D\u59CB\u5316: ${file.basename}`);
  }
  render() {
    const metricsContent = this.container.createEl("div", { cls: "metrics-content" });
    const isRoamingDoc = this.plugin.settings.roamingDocs.includes(this.file.path);
    console.log(`\u6E32\u67D3\u6587\u6863\u6307\u6807: ${this.file.basename}, \u662F\u5426\u6F2B\u6E38: ${isRoamingDoc}`);
    if (isRoamingDoc) {
      this.createCustomMetricsSection(metricsContent);
      this.createPrioritySection(metricsContent);
      this.createVisitStatsSection(metricsContent);
    } else {
      this.createNonRoamingPrompt(metricsContent);
    }
    return metricsContent;
  }
  createNonRoamingPrompt(metricsContent) {
    const promptSection = metricsContent.createEl("div", { cls: "non-roaming-prompt" });
    const header = promptSection.createEl("div", { cls: "prompt-header" });
    header.createEl("span", { cls: "prompt-icon", text: "\u{1F4CB}" });
    header.createEl("h3", { cls: "prompt-title", text: i18n.t("view.nonRoaming.title") });
    const description = promptSection.createEl("p", { cls: "prompt-description" });
    description.textContent = i18n.t("view.nonRoaming.description");
    const benefitsList = promptSection.createEl("ul", { cls: "benefits-list" });
    const benefits = i18n.t("view.nonRoaming.benefits");
    benefits.forEach((benefit) => {
      const li = benefitsList.createEl("li");
      li.textContent = benefit;
    });
    const actionSection = promptSection.createEl("div", { cls: "prompt-action" });
    const addButton = actionSection.createEl("button", {
      cls: "add-to-roaming-btn",
      text: "+ " + i18n.t("view.nonRoaming.action")
    });
    addButton.onclick = async () => {
      try {
        if (this.file.extension !== "md") {
          new import_obsidian2.Notice(i18n.t("notices.onlyMarkdownFiles"));
          return;
        }
        if (!this.plugin.settings.roamingDocs.includes(this.file.path)) {
          this.plugin.settings.roamingDocs.push(this.file.path);
          const fileService = this.plugin.fileManagementService;
          const defaultMetrics = fileService.createDefaultMetricsForFile(this.file);
          await this.plugin.updateDocumentMetrics(this.file, defaultMetrics);
          await this.plugin.saveSettings();
          new import_obsidian2.Notice(i18n.t("notices.addedToRoaming", { filename: this.file.basename }));
          this.container.empty();
          this.render();
          this.onMetricsUpdated();
        }
      } catch (error) {
        console.error("\u52A0\u5165\u6F2B\u6E38\u5931\u8D25:", error);
        new import_obsidian2.Notice(i18n.t("notices.errorSavingSettings"));
      }
    };
  }
  async updateDocumentMetricsRealTime(file, realTimeMetrics) {
    try {
      this.plugin.settings.documentMetrics[file.path] = {
        ...realTimeMetrics,
        lastVisited: Date.now()
      };
    } catch (error) {
      console.warn("\u5B9E\u65F6\u6307\u6807\u66F4\u65B0\u5931\u8D25:", error);
    }
  }
  updateMetricValueColor(valueElement, value) {
    if (value >= 8) {
      valueElement.style.color = "#dc3545";
    } else if (value >= 6) {
      valueElement.style.color = "#fd7e14";
    } else if (value >= 4) {
      valueElement.style.color = "#ffc107";
    } else {
      valueElement.style.color = "#28a745";
    }
  }
  updatePriorityDisplay(metricsContent) {
    const priorityValue = metricsContent.querySelector(".priority-value");
    if (priorityValue) {
      const calculatedPriority = this.calculatePriority(this.metrics);
      priorityValue.textContent = calculatedPriority.toFixed(2);
      priorityValue.style.color = SharedUtils.getPriorityColor(calculatedPriority);
    }
    const breakdown = metricsContent.querySelector(".breakdown-list");
    if (breakdown) {
      breakdown.empty();
      this.createWeightBreakdownContent(breakdown);
    }
  }
  createWeightBreakdownContent(breakdown) {
    const customMetrics = this.plugin.settings.customMetrics;
    const weights = this.plugin.settings.metricWeights;
    for (const metric of customMetrics) {
      const metricValue = this.metrics[metric.id] || 0;
      const metricWeight = weights[metric.id] || metric.weight;
      const normalizedWeight = metricWeight / 100;
      const score = metricValue * normalizedWeight;
      const breakdownItem = breakdown.createEl("div", { cls: "breakdown-item" });
      breakdownItem.createEl("span", {
        cls: "breakdown-label",
        text: `${i18n.getMetricName(metric)} (${metricWeight}%):`
      });
      breakdownItem.createEl("span", {
        cls: "breakdown-score",
        text: `${metricValue} \xD7 ${normalizedWeight.toFixed(2)} = ${score.toFixed(2)}`
      });
    }
    const totalScore = this.calculatePriority(this.metrics);
    const totalItem = breakdown.createEl("div", { cls: "breakdown-item total" });
    totalItem.createEl("span", { cls: "breakdown-label", text: i18n.t("metrics.totalLabel") + ":" });
    totalItem.createEl("span", { cls: "breakdown-score total-score", text: totalScore.toFixed(2) });
  }
  createPrioritySection(metricsContent) {
    const prioritySection = metricsContent.createEl("div", { cls: "priority-section" });
    prioritySection.createEl("div", { cls: "priority-label", text: i18n.t("metrics.priorityLabel") });
    const calculatedPriority = this.calculatePriority(this.metrics);
    const priorityValue = prioritySection.createEl("div", {
      cls: "priority-value",
      text: calculatedPriority.toFixed(2)
    });
    const breakdown = metricsContent.createEl("div", { cls: "weight-breakdown" });
    this.createWeightBreakdown(breakdown);
  }
  createCustomMetricsSection(metricsContent) {
    const customMetricsSection = metricsContent.createEl("div", { cls: "custom-metrics-section" });
    customMetricsSection.createEl("h4", { text: i18n.t("metrics.customMetricsTitle") });
    const metricsList = customMetricsSection.createEl("div", { cls: "metrics-list" });
    for (const metric of this.plugin.settings.customMetrics) {
      const metricItem = metricsList.createEl("div", { cls: "metric-item" });
      const labelRow = metricItem.createEl("div", { cls: "metric-label-row" });
      const label = labelRow.createEl("span", { cls: "metric-label", text: `${i18n.getMetricName(metric)} (${metric.weight}%):` });
      const valueDisplay = labelRow.createEl("span", {
        cls: "metric-value",
        text: (this.metrics[metric.id] || 5).toFixed(1)
      });
      const metricValue = this.metrics[metric.id] || 5;
      this.updateMetricValueColor(valueDisplay, metricValue);
      const slider = metricItem.createEl("input", {
        type: "range",
        cls: "metric-slider",
        attr: {
          min: "0",
          max: "10",
          step: "0.5",
          "data-metric-id": metric.id
        }
      });
      slider.value = metricValue.toString();
      let updateTimeout = null;
      const debouncedUpdate = async (newValue) => {
        if (updateTimeout) {
          clearTimeout(updateTimeout);
        }
        updateTimeout = setTimeout(async () => {
          try {
            this.metrics[metric.id] = newValue;
            await this.updateDocumentMetricsRealTime(this.file, this.metrics);
            this.updatePriorityDisplay(metricsContent);
            this.onMetricsUpdated();
          } catch (error) {
            console.warn("Failed to update metric:", error);
          }
        }, 300);
      };
      slider.addEventListener("input", () => {
        const newValue = parseFloat(slider.value);
        valueDisplay.textContent = newValue.toFixed(1);
        this.updateMetricValueColor(valueDisplay, newValue);
        debouncedUpdate(newValue);
      });
      slider.addEventListener("change", async () => {
        const newValue = parseFloat(slider.value);
        valueDisplay.textContent = newValue.toFixed(1);
        this.updateMetricValueColor(valueDisplay, newValue);
        this.metrics[metric.id] = newValue;
        await this.updateDocumentMetricsRealTime(this.file, this.metrics);
        this.updatePriorityDisplay(metricsContent);
        this.onMetricsUpdated();
      });
      slider.addEventListener("keydown", (e) => {
        const currentValue = parseFloat(slider.value);
        let newValue = currentValue;
        switch (e.key) {
          case "ArrowLeft":
          case "ArrowDown":
            newValue = Math.max(0, currentValue - 0.5);
            break;
          case "ArrowRight":
          case "ArrowUp":
            newValue = Math.min(10, currentValue + 0.5);
            break;
          case "Home":
            newValue = 0;
            break;
          case "End":
            newValue = 10;
            break;
          default:
            return;
        }
        e.preventDefault();
        slider.value = newValue.toString();
        valueDisplay.textContent = newValue.toFixed(1);
        this.updateMetricValueColor(valueDisplay, newValue);
        debouncedUpdate(newValue);
      });
      const updateSliderBackground = () => {
        const value = parseFloat(slider.value);
        const percentage = value / 10 * 100;
        slider.style.background = `linear-gradient(to right, var(--accent-color) 0%, var(--accent-color) ${percentage}%, rgba(0,0,0,0.1) ${percentage}%, rgba(0,0,0,0.1) 100%)`;
      };
      slider.addEventListener("input", updateSliderBackground);
      updateSliderBackground();
    }
  }
  createVisitStatsSection(metricsContent) {
    const visitSection = metricsContent.createEl("div", { cls: "visit-section" });
    visitSection.createEl("h4", { text: i18n.t("metrics.visitStatsTitle") });
    const visitStats = visitSection.createEl("div", { cls: "visit-stats" });
    const visitCount = visitStats.createEl("div", { cls: "visit-stat" });
    visitCount.createEl("span", { cls: "stat-label", text: i18n.t("metrics.visitCountLabel") + ": " });
    visitCount.createEl("span", { cls: "stat-value", text: this.metrics.visitCount.toString() });
    const lastVisited = visitStats.createEl("div", { cls: "visit-stat" });
    lastVisited.createEl("span", { cls: "stat-label", text: i18n.t("metrics.lastVisitedLabel") + ": " });
    if (this.metrics.lastVisited) {
      const lastVisitedDate = new Date(this.metrics.lastVisited);
      lastVisited.createEl("span", {
        cls: "stat-value",
        text: lastVisitedDate.toLocaleString()
      });
    } else {
      lastVisited.createEl("span", { cls: "stat-value", text: i18n.t("metrics.neverVisited") });
    }
  }
  createWeightBreakdown(breakdown) {
    breakdown.createEl("h5", { text: i18n.t("metrics.weightBreakdown") });
    const breakdownList = breakdown.createEl("div", { cls: "breakdown-list" });
    this.createWeightBreakdownContent(breakdownList);
  }
  calculatePriority(metrics) {
    const customMetrics = this.plugin.settings.customMetrics;
    const weights = this.plugin.settings.metricWeights;
    let totalScore = 0;
    let totalWeight = 0;
    for (const metric of customMetrics) {
      const metricValue = metrics[metric.id] || 5;
      const metricWeight = weights[metric.id] || metric.weight;
      const normalizedWeight = metricWeight / 100;
      const score = metricValue * normalizedWeight;
      totalScore += score;
      totalWeight += normalizedWeight;
    }
    return totalWeight > 0 ? totalScore / totalWeight * 10 : 0;
  }
  /**
   * 更新指标数据和文件
   */
  updateMetrics(fileOrMetrics, metrics) {
    if (fileOrMetrics instanceof import_obsidian2.TFile && metrics) {
      console.log(`DocumentMetricsDisplay \u66F4\u65B0: ${this.file.basename} -> ${fileOrMetrics.basename}`);
      this.file = fileOrMetrics;
      this.metrics = metrics;
    } else if (fileOrMetrics && !metrics) {
      console.log(`DocumentMetricsDisplay \u66F4\u65B0\u6307\u6807: ${this.file.basename}`);
      this.metrics = fileOrMetrics;
    }
    this.container.empty();
    this.render();
  }
};

// src/views/components/NavigationTabs.ts
var NavigationTabs = class {
  constructor(container, onTabChange, initialTab = "metrics") {
    this.tabSlider = null;
    this.tabButtons = [];
    this.currentActiveTab = "";
    this.currentTabIndex = 0;
    this.container = container;
    this.onTabChange = onTabChange;
    this.currentActiveTab = initialTab;
    this.create();
  }
  create() {
    const navSection = this.container.createEl("div", { cls: "sliding-navigation" });
    const tabContainer = navSection.createEl("div", { cls: "tabs-wrapper" });
    this.tabSlider = tabContainer.createEl("div", { cls: "tab-slider" });
    const tabs = [
      { id: "metrics", label: i18n.t("tabs.metrics") },
      { id: "recommendations", label: i18n.t("tabs.recommendations") },
      { id: "ranking", label: i18n.t("tabs.ranking") },
      { id: "visualization", label: i18n.t("tabs.visualization") }
    ];
    this.tabButtons = [];
    tabs.forEach((tab, index) => {
      const tabBtn = tabContainer.createEl("button", {
        cls: "tab-btn",
        text: tab.label
      });
      tabBtn.setAttribute("data-target", tab.id);
      tabBtn.onclick = () => this.switchToTab(tab.id, index);
      if (tab.id === this.currentActiveTab) {
        tabBtn.addClass("active");
        this.currentTabIndex = index;
      }
      this.tabButtons.push(tabBtn);
    });
    this.updateTabSlider();
  }
  switchToTab(tabId, index) {
    if (this.currentActiveTab === tabId)
      return;
    this.tabButtons.forEach((btn, i) => {
      btn.toggleClass("active", i === index);
    });
    this.currentActiveTab = tabId;
    this.currentTabIndex = index;
    this.updateTabSlider();
    this.onTabChange(tabId, index);
  }
  updateTabSlider() {
    if (!this.tabSlider || !this.tabButtons[this.currentTabIndex])
      return;
    const activeTab = this.tabButtons[this.currentTabIndex];
    const tabRect = activeTab.getBoundingClientRect();
    const containerRect = activeTab.parentElement.getBoundingClientRect();
    this.tabSlider.style.width = `${tabRect.width}px`;
    this.tabSlider.style.left = `${tabRect.left - containerRect.left}px`;
  }
  /**
   * 获取当前激活的标签ID
   */
  getCurrentTab() {
    return this.currentActiveTab;
  }
  /**
   * 获取当前激活的标签索引
   */
  getCurrentTabIndex() {
    return this.currentTabIndex;
  }
  /**
   * 切换到指定标签
   */
  setActiveTab(tabId) {
    const tabIndex = this.tabButtons.findIndex((btn) => btn.getAttribute("data-target") === tabId);
    if (tabIndex !== -1) {
      this.switchToTab(tabId, tabIndex);
    }
  }
  /**
   * 刷新标签文本（语言切换时使用）
   */
  refresh() {
    this.container.empty();
    this.create();
  }
};

// src/views/components/RankingList.ts
var RankingList = class {
  constructor(container, plugin, callbacks) {
    this.currentRankingType = "priority";
    this.container = container;
    this.plugin = plugin;
    this.onOpenDocument = callbacks.onOpenDocument;
    this.onEditMetrics = callbacks.onEditMetrics;
  }
  render() {
    this.container.empty();
    const rankingSection = this.container.createEl("div", { cls: "ranking-section" });
    const headerContainer = rankingSection.createEl("div", { cls: "ranking-header" });
    const title = headerContainer.createEl("h3", { text: i18n.t("ranking.title") });
    const toggleContainer = headerContainer.createEl("div", { cls: "ranking-toggle" });
    const priorityBtn = toggleContainer.createEl("button", {
      cls: `toggle-btn ${this.currentRankingType === "priority" ? "active" : ""}`,
      text: i18n.t("ranking.priorityToggle")
    });
    priorityBtn.onclick = () => this.switchRankingType("priority");
    const visitsBtn = toggleContainer.createEl("button", {
      cls: `toggle-btn ${this.currentRankingType === "visits" ? "active" : ""}`,
      text: i18n.t("ranking.visitsToggle")
    });
    visitsBtn.onclick = () => this.switchRankingType("visits");
    const rankingList = rankingSection.createEl("div", { cls: "ranking-list" });
    const rankedDocuments = this.currentRankingType === "priority" ? this.getDocumentsByPriority() : this.getDocumentsByVisits();
    if (rankedDocuments.length === 0) {
      rankingList.createEl("p", {
        text: i18n.t("ranking.emptyMessage"),
        cls: "empty-message"
      });
      return;
    }
    const topDocuments = rankedDocuments.slice(0, 10);
    topDocuments.forEach(({ file, score, metrics }, index) => {
      const rankingItem = this.createRankingItem(file, score, metrics, index + 1);
      rankingList.appendChild(rankingItem);
    });
    const refreshBtn = rankingSection.createEl("button", {
      cls: "refresh-ranking-btn",
      text: i18n.t("ranking.refreshButton")
    });
    refreshBtn.onclick = () => this.render();
  }
  getDocumentsByPriority() {
    const files = this.plugin.getValidRoamingFiles();
    const documentsWithPriority = files.map((file) => {
      const metrics = this.plugin.getDocumentMetrics(file);
      const priority = SharedUtils.calculatePriority(metrics, this.plugin.settings.metricWeights, this.plugin.settings.customMetrics);
      return { file, score: priority, metrics };
    });
    return documentsWithPriority.sort((a, b) => b.score - a.score);
  }
  getDocumentsByVisits() {
    const files = this.plugin.getValidRoamingFiles();
    const documentsWithVisits = files.map((file) => {
      const metrics = this.plugin.getDocumentMetrics(file);
      const visitCount = metrics.visitCount || 0;
      return { file, score: visitCount, metrics };
    });
    return documentsWithVisits.sort((a, b) => b.score - a.score);
  }
  switchRankingType(type) {
    this.currentRankingType = type;
    this.render();
  }
  createRankingItem(file, score, metrics, rank) {
    const item = document.createElement("div");
    item.className = "ranking-item";
    const rankBadge = item.createEl("span", { cls: "rank-badge" });
    rankBadge.textContent = rank.toString();
    if (rank === 1) {
      rankBadge.addClass("gold");
    } else if (rank === 2) {
      rankBadge.addClass("silver");
    } else if (rank === 3) {
      rankBadge.addClass("bronze");
    }
    const fileInfo = item.createEl("div", { cls: "file-info" });
    const fileName = fileInfo.createEl("div", { cls: "file-name" });
    fileName.textContent = file.basename;
    fileName.title = file.path;
    const filePath = fileInfo.createEl("div", { cls: "file-path" });
    filePath.textContent = file.path;
    const scoreInfo = item.createEl("div", { cls: "score-info" });
    const mainScoreEl = scoreInfo.createEl("span", { cls: "main-score" });
    if (this.currentRankingType === "priority") {
      mainScoreEl.textContent = `${i18n.t("metrics.priorityLabel")}: ${score.toFixed(1)}`;
      mainScoreEl.style.color = SharedUtils.getPriorityColor(score);
    } else {
      mainScoreEl.textContent = `${i18n.t("ranking.visits")}: ${score}`;
      mainScoreEl.style.color = this.getVisitCountColor(score);
    }
    const actions = item.createEl("div", { cls: "actions" });
    const openBtn = actions.createEl("button", {
      cls: "open-btn",
      text: "\u{1F4D6} " + i18n.t("ranking.openButton")
    });
    openBtn.title = i18n.t("view.openDocument");
    openBtn.onclick = () => this.onOpenDocument(file);
    return item;
  }
  getVisitCountColor(visits) {
    if (visits >= 10) {
      return "#dc3545";
    } else if (visits >= 5) {
      return "#fd7e14";
    } else if (visits >= 2) {
      return "#ffc107";
    } else {
      return "#28a745";
    }
  }
  /**
   * 刷新排行榜数据
   */
  refresh() {
    this.render();
  }
};

// src/views/components/RecommendationList.ts
var import_obsidian3 = require("obsidian");
var RecommendationList = class {
  constructor(container, plugin, callbacks) {
    this.cachedRecommendations = [];
    this.container = container;
    this.plugin = plugin;
    this.onOpenDocument = callbacks.onOpenDocument;
    this.onEditMetrics = callbacks.onEditMetrics;
  }
  render(recommendations) {
    this.container.empty();
    const recommendationsSection = this.container.createEl("div", { cls: "recommendations-section" });
    recommendationsSection.createEl("h3", { text: i18n.t("recommendations.title") });
    if (recommendations.length === 0) {
      recommendationsSection.createEl("p", {
        text: i18n.t("recommendations.emptyMessage"),
        cls: "empty-message"
      });
      return;
    }
    const recommendationsList = recommendationsSection.createEl("div", { cls: "recommendations-list" });
    recommendations.forEach((file, index) => {
      const recItem = this.createRecommendationItem(file, index);
      recommendationsList.appendChild(recItem);
    });
    const buttonContainer = recommendationsSection.createEl("div", { cls: "recommendation-buttons" });
    const refreshBtn = buttonContainer.createEl("button", {
      cls: "refresh-recommendations-btn",
      text: i18n.t("recommendations.refreshButton")
    });
    refreshBtn.onclick = () => this.refresh();
    const smartJumpBtn = buttonContainer.createEl("button", {
      cls: "smart-jump-btn",
      text: i18n.t("recommendations.smartJumpButton")
    });
    smartJumpBtn.onclick = async () => {
      try {
        const recommendations2 = await this.plugin.recommendationService.getRecommendations();
        if (recommendations2.length === 0) {
          new import_obsidian3.Notice(i18n.t("recommendations.emptyMessage"));
          return;
        }
        const topRecommendation = recommendations2[0];
        const similarity = (topRecommendation.score * 100).toFixed(1);
        await this.onOpenDocument(topRecommendation.file);
        new import_obsidian3.Notice(i18n.t("recommendations.smartJumpNotice", {
          filename: topRecommendation.file.basename,
          similarity
        }));
      } catch (error) {
        console.error("\u667A\u80FD\u8DF3\u8F6C\u5931\u8D25:", error);
        new import_obsidian3.Notice(i18n.t("recommendations.smartJumpFailed"));
      }
    };
  }
  renderWithScores(recommendations) {
    this.container.empty();
    this.cachedRecommendations = recommendations;
    const recommendationsSection = this.container.createEl("div", { cls: "recommendations-section" });
    recommendationsSection.createEl("h3", { text: i18n.t("recommendations.title") });
    if (recommendations.length === 0) {
      recommendationsSection.createEl("p", {
        text: i18n.t("recommendations.emptyMessage"),
        cls: "empty-message"
      });
      return;
    }
    const recommendationsList = recommendationsSection.createEl("div", { cls: "recommendations-list" });
    recommendations.forEach((rec, index) => {
      const recItem = this.createRecommendationItemWithScore(rec, index);
      recommendationsList.appendChild(recItem);
    });
    const buttonContainer = recommendationsSection.createEl("div", { cls: "recommendation-buttons" });
    const refreshBtn = buttonContainer.createEl("button", {
      cls: "refresh-recommendations-btn",
      text: i18n.t("recommendations.refreshButton")
    });
    refreshBtn.onclick = () => this.refresh();
    const smartJumpBtn = buttonContainer.createEl("button", {
      cls: "smart-jump-btn",
      text: i18n.t("recommendations.smartJumpButton")
    });
    smartJumpBtn.onclick = async () => {
      try {
        const recommendations2 = await this.plugin.recommendationService.getRecommendations();
        if (recommendations2.length === 0) {
          new import_obsidian3.Notice(i18n.t("recommendations.emptyMessage"));
          return;
        }
        const topRecommendation = recommendations2[0];
        const similarity = (topRecommendation.score * 100).toFixed(1);
        await this.onOpenDocument(topRecommendation.file);
        new import_obsidian3.Notice(i18n.t("recommendations.smartJumpNotice", {
          filename: topRecommendation.file.basename,
          similarity
        }));
      } catch (error) {
        console.error("\u667A\u80FD\u8DF3\u8F6C\u5931\u8D25:", error);
        new import_obsidian3.Notice(i18n.t("recommendations.smartJumpFailed"));
      }
    };
  }
  createRecommendationItem(file, index) {
    const recItem = document.createElement("div");
    recItem.className = "recommendation-item";
    recItem.setAttribute("data-file-path", file.path);
    const recNumber = recItem.createEl("span", { cls: "rec-number" });
    recNumber.textContent = (index + 1).toString();
    const fileInfo = recItem.createEl("div", { cls: "file-info" });
    const fileName = fileInfo.createEl("div", { cls: "file-name" });
    fileName.textContent = file.basename;
    fileName.title = file.path;
    const metricsInfo = recItem.createEl("div", { cls: "metrics-info" });
    const metrics = this.plugin.getDocumentMetrics(file);
    const calculatedPriority = SharedUtils.calculatePriority(metrics, this.plugin.settings.metricWeights, this.plugin.settings.customMetrics);
    const priorityEl = metricsInfo.createEl("span", { cls: "priority" });
    priorityEl.textContent = `${i18n.t("recommendations.priorityLabel")}: ${calculatedPriority.toFixed(1)}`;
    priorityEl.style.color = SharedUtils.getPriorityColor(calculatedPriority);
    for (const metric of this.plugin.settings.customMetrics.slice(0, 2)) {
      const metricEl = metricsInfo.createEl("span", { cls: "metric" });
      const metricValue = metrics[metric.id] || 0;
      metricEl.textContent = `${metric.name}: ${metricValue.toFixed(1)}`;
    }
    const visitEl = metricsInfo.createEl("span", { cls: "visit-count" });
    visitEl.textContent = `${i18n.t("recommendations.visitCountLabel")}: ${metrics.visitCount || 0}`;
    const actions = recItem.createEl("div", { cls: "quick-actions" });
    const openBtn = actions.createEl("button", { text: i18n.t("recommendations.openButton") });
    openBtn.onclick = () => this.onOpenDocument(file);
    return recItem;
  }
  createRecommendationItemWithScore(rec, index) {
    const recItem = document.createElement("div");
    recItem.className = "recommendation-item";
    recItem.setAttribute("data-file-path", rec.file.path);
    const recNumber = recItem.createEl("span", { cls: "rec-number" });
    recNumber.textContent = (index + 1).toString();
    const fileInfo = recItem.createEl("div", { cls: "file-info" });
    const fileName = fileInfo.createEl("div", { cls: "file-name" });
    fileName.textContent = rec.file.basename;
    fileName.title = rec.file.path;
    const similarityInfo = recItem.createEl("div", { cls: "similarity-info" });
    const similarityEl = similarityInfo.createEl("span", { cls: "similarity-score-large" });
    similarityEl.textContent = `${i18n.t("recommendations.similarity")}: ${(rec.score * 100).toFixed(1)}%`;
    similarityEl.style.color = this.getSimilarityColor(rec.score);
    const actions = recItem.createEl("div", { cls: "quick-actions" });
    const openBtn = actions.createEl("button", { text: i18n.t("recommendations.openButton") });
    openBtn.onclick = () => this.onOpenDocument(rec.file);
    return recItem;
  }
  getSimilarityColor(score) {
    if (score >= 0.8) {
      return "#dc3545";
    } else if (score >= 0.6) {
      return "#fd7e14";
    } else if (score >= 0.4) {
      return "#ffc107";
    } else {
      return "#28a745";
    }
  }
  /**
   * 刷新推荐列表
   */
  async refresh() {
    try {
      const recommendations = await this.plugin.recommendationService.getRecommendations();
      this.renderWithScores(recommendations);
    } catch (error) {
      console.error("\u5237\u65B0\u63A8\u8350\u5931\u8D25:", error);
    }
  }
  /**
   * 更新特定文件项的显示
   */
  updateFileItem(filePath) {
    const fileItem = this.container.querySelector(`[data-file-path="${filePath}"]`);
    if (fileItem) {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        const metrics = this.plugin.getDocumentMetrics(file);
        const priorityEl = fileItem.querySelector(".priority");
        if (priorityEl) {
          const calculatedPriority = SharedUtils.calculatePriority(metrics, this.plugin.settings.metricWeights, this.plugin.settings.customMetrics);
          priorityEl.textContent = `${i18n.t("recommendations.priorityLabel")}: ${calculatedPriority.toFixed(1)}`;
          priorityEl.setAttribute("style", `color: ${SharedUtils.getPriorityColor(calculatedPriority)}`);
        }
      }
    }
  }
};

// src/views/components/PriorityVisualization.ts
var PriorityVisualization = class {
  constructor(container, plugin, onOpenDocument) {
    this.canvas = null;
    this.ctx = null;
    this.hoveredPoint = null;
    this.container = container;
    this.plugin = plugin;
    this.onOpenDocument = onOpenDocument;
    this.render();
  }
  render() {
    this.container.empty();
    const vizSection = this.container.createEl("div", { cls: "priority-visualization-section" });
    const header = vizSection.createEl("div", { cls: "viz-header" });
    header.createEl("h3", { text: i18n.t("visualization.title") });
    const refreshBtn = header.createEl("button", {
      cls: "viz-refresh-btn",
      text: i18n.t("visualization.refresh")
    });
    refreshBtn.onclick = () => this.render();
    const canvasContainer = vizSection.createEl("div", { cls: "viz-canvas-container" });
    this.canvas = canvasContainer.createEl("canvas", { cls: "priority-viz-canvas" });
    this.ctx = this.canvas.getContext("2d");
    const width = canvasContainer.clientWidth || 800;
    const height = 400;
    this.canvas.width = width;
    this.canvas.height = height;
    this.drawChart();
    this.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e));
    this.canvas.addEventListener("click", (e) => this.handleClick(e));
    this.canvas.addEventListener("mouseleave", () => {
      this.hoveredPoint = null;
      this.drawChart();
    });
  }
  drawChart() {
    if (!this.ctx || !this.canvas)
      return;
    const files = this.plugin.getValidRoamingFiles();
    if (files.length === 0) {
      this.drawEmptyState();
      return;
    }
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    const dataPoints = files.map((file) => {
      const metrics = this.plugin.getDocumentMetrics(file);
      const priority = SharedUtils.calculatePriority(
        metrics,
        this.plugin.settings.metricWeights,
        this.plugin.settings.customMetrics
      );
      return { file, priority };
    }).sort((a, b) => b.priority - a.priority);
    const padding = { top: 40, right: 40, bottom: 60, left: 60 };
    const chartWidth = this.canvas.width - padding.left - padding.right;
    const chartHeight = this.canvas.height - padding.top - padding.bottom;
    const maxPriority = Math.max(...dataPoints.map((d) => d.priority));
    const minPriority = Math.min(...dataPoints.map((d) => d.priority));
    const priorityRange = maxPriority - minPriority || 1;
    this.drawGrid(padding, chartWidth, chartHeight, maxPriority, minPriority);
    this.drawAxes(padding, chartWidth, chartHeight, dataPoints.length, maxPriority, minPriority);
    dataPoints.forEach((point, index) => {
      const x = padding.left + index / Math.max(1, dataPoints.length - 1) * chartWidth;
      const y = padding.top + chartHeight - (point.priority - minPriority) / priorityRange * chartHeight;
      this.drawPoint(x, y, point, index);
    });
    if (this.hoveredPoint) {
      this.drawTooltip(this.hoveredPoint);
    }
  }
  drawGrid(padding, width, height, maxPriority, minPriority) {
    if (!this.ctx)
      return;
    this.ctx.strokeStyle = "#e0e0e0";
    this.ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const y = padding.top + i / 5 * height;
      this.ctx.beginPath();
      this.ctx.moveTo(padding.left, y);
      this.ctx.lineTo(padding.left + width, y);
      this.ctx.stroke();
    }
    for (let i = 0; i <= 10; i++) {
      const x = padding.left + i / 10 * width;
      this.ctx.beginPath();
      this.ctx.moveTo(x, padding.top);
      this.ctx.lineTo(x, padding.top + height);
      this.ctx.stroke();
    }
  }
  drawAxes(padding, width, height, fileCount, maxPriority, minPriority) {
    if (!this.ctx)
      return;
    this.ctx.strokeStyle = "#333";
    this.ctx.lineWidth = 2;
    this.ctx.font = "12px sans-serif";
    this.ctx.fillStyle = "#333";
    this.ctx.beginPath();
    this.ctx.moveTo(padding.left, padding.top);
    this.ctx.lineTo(padding.left, padding.top + height);
    this.ctx.stroke();
    this.ctx.beginPath();
    this.ctx.moveTo(padding.left, padding.top + height);
    this.ctx.lineTo(padding.left + width, padding.top + height);
    this.ctx.stroke();
    this.ctx.textAlign = "right";
    this.ctx.textBaseline = "middle";
    for (let i = 0; i <= 5; i++) {
      const value = maxPriority - i / 5 * (maxPriority - minPriority);
      const y = padding.top + i / 5 * height;
      this.ctx.fillText(value.toFixed(0), padding.left - 10, y);
    }
    this.ctx.save();
    this.ctx.translate(20, padding.top + height / 2);
    this.ctx.rotate(-Math.PI / 2);
    this.ctx.textAlign = "center";
    this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--accent-color").trim() || "#8e44ad";
    this.ctx.font = "bold 14px sans-serif";
    this.ctx.fillText(i18n.t("visualization.yAxis"), 0, 0);
    this.ctx.restore();
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "top";
    const step = Math.ceil(fileCount / 10);
    for (let i = 0; i < fileCount; i += step) {
      const x = padding.left + i / Math.max(1, fileCount - 1) * width;
      this.ctx.fillText(`#${i + 1}`, x, padding.top + height + 10);
    }
    this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--accent-color").trim() || "#8e44ad";
    this.ctx.font = "bold 14px sans-serif";
    this.ctx.fillText(i18n.t("visualization.xAxis"), padding.left + width / 2, padding.top + height + 40);
  }
  drawPoint(x, y, point, index) {
    var _a;
    if (!this.ctx)
      return;
    const isHovered = ((_a = this.hoveredPoint) == null ? void 0 : _a.file.path) === point.file.path;
    const radius = isHovered ? 8 : 5;
    this.ctx.beginPath();
    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
    const color = this.getPriorityColor(point.priority);
    this.ctx.fillStyle = color;
    this.ctx.fill();
    const accentColor = getComputedStyle(document.documentElement).getPropertyValue("--accent-color").trim() || "#8e44ad";
    this.ctx.strokeStyle = isHovered ? accentColor : "#fff";
    this.ctx.lineWidth = isHovered ? 3 : 2;
    this.ctx.stroke();
    if (!isHovered) {
    }
  }
  drawTooltip(point) {
    if (!this.ctx || !this.canvas)
      return;
    const padding = 10;
    const lineHeight = 18;
    const fileName = point.file.basename;
    const priorityText = `${i18n.t("metrics.priorityLabel")}: ${point.priority.toFixed(1)}`;
    this.ctx.font = "12px sans-serif";
    const fileNameWidth = this.ctx.measureText(fileName).width;
    const priorityWidth = this.ctx.measureText(priorityText).width;
    const tooltipWidth = Math.max(fileNameWidth, priorityWidth) + padding * 2;
    const tooltipHeight = lineHeight * 2 + padding * 2;
    let tooltipX = point.x + 10;
    let tooltipY = point.y - tooltipHeight - 10;
    if (tooltipX + tooltipWidth > this.canvas.width) {
      tooltipX = point.x - tooltipWidth - 10;
    }
    if (tooltipY < 0) {
      tooltipY = point.y + 10;
    }
    this.ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
    const accentColor = getComputedStyle(document.documentElement).getPropertyValue("--accent-color").trim() || "#8e44ad";
    this.ctx.strokeStyle = accentColor;
    this.ctx.lineWidth = 2;
    const radius = 8;
    this.ctx.beginPath();
    this.ctx.moveTo(tooltipX + radius, tooltipY);
    this.ctx.lineTo(tooltipX + tooltipWidth - radius, tooltipY);
    this.ctx.arcTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + radius, radius);
    this.ctx.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - radius);
    this.ctx.arcTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - radius, tooltipY + tooltipHeight, radius);
    this.ctx.lineTo(tooltipX + radius, tooltipY + tooltipHeight);
    this.ctx.arcTo(tooltipX, tooltipY + tooltipHeight, tooltipX, tooltipY + tooltipHeight - radius, radius);
    this.ctx.lineTo(tooltipX, tooltipY + radius);
    this.ctx.arcTo(tooltipX, tooltipY, tooltipX + radius, tooltipY, radius);
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
    this.ctx.fillStyle = "#2c3e50";
    this.ctx.textAlign = "left";
    this.ctx.textBaseline = "top";
    this.ctx.font = "bold 12px sans-serif";
    this.ctx.fillText(fileName, tooltipX + padding, tooltipY + padding);
    this.ctx.font = "12px sans-serif";
    this.ctx.fillStyle = accentColor;
    this.ctx.fillText(priorityText, tooltipX + padding, tooltipY + padding + lineHeight);
  }
  getPriorityColor(priority) {
    if (priority >= 80)
      return "#dc3545";
    if (priority >= 60)
      return "#fd7e14";
    if (priority >= 40)
      return "#ffc107";
    if (priority >= 20)
      return "#28a745";
    return "#6c757d";
  }
  drawEmptyState() {
    if (!this.ctx || !this.canvas)
      return;
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "#7f8c8d";
    this.ctx.font = "16px sans-serif";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    this.ctx.fillText(
      i18n.t("visualization.emptyMessage"),
      this.canvas.width / 2,
      this.canvas.height / 2
    );
  }
  handleMouseMove(event) {
    if (!this.canvas)
      return;
    const rect = this.canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    const files = this.plugin.getValidRoamingFiles();
    if (files.length === 0)
      return;
    const dataPoints = files.map((file) => {
      const metrics = this.plugin.getDocumentMetrics(file);
      const priority = SharedUtils.calculatePriority(
        metrics,
        this.plugin.settings.metricWeights,
        this.plugin.settings.customMetrics
      );
      return { file, priority };
    }).sort((a, b) => b.priority - a.priority);
    const padding = { top: 40, right: 40, bottom: 60, left: 60 };
    const chartWidth = this.canvas.width - padding.left - padding.right;
    const chartHeight = this.canvas.height - padding.top - padding.bottom;
    const maxPriority = Math.max(...dataPoints.map((d) => d.priority));
    const minPriority = Math.min(...dataPoints.map((d) => d.priority));
    const priorityRange = maxPriority - minPriority || 1;
    let foundPoint = null;
    for (let i = 0; i < dataPoints.length; i++) {
      const point = dataPoints[i];
      const x = padding.left + i / Math.max(1, dataPoints.length - 1) * chartWidth;
      const y = padding.top + chartHeight - (point.priority - minPriority) / priorityRange * chartHeight;
      const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
      if (distance < 10) {
        foundPoint = { file: point.file, x, y, priority: point.priority };
        break;
      }
    }
    if (foundPoint !== this.hoveredPoint) {
      this.hoveredPoint = foundPoint;
      this.canvas.style.cursor = foundPoint ? "pointer" : "default";
      this.drawChart();
    }
  }
  handleClick(event) {
    if (this.hoveredPoint) {
      this.onOpenDocument(this.hoveredPoint.file);
    }
  }
  refresh() {
    this.render();
  }
};

// src/views/IncrementalReadingView.ts
var VIEW_TYPE_INCREMENTAL_READING = "incremental-reading-view";
var IncrementalReadingView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.currentMetrics = null;
    this.lastProcessedFile = null;
    this.lastProcessedTime = 0;
    // 状态元素
    this.statusText = null;
    // 组件实例
    this.actionBar = null;
    this.documentMetricsDisplay = null;
    this.navigationTabs = null;
    this.rankingList = null;
    this.recommendationList = null;
    this.priorityVisualization = null;
    // 视图状态
    this.currentActiveTab = "metrics";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_INCREMENTAL_READING;
  }
  getDisplayText() {
    return i18n.t("view.title");
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    this.plugin.applyColorScheme(this.plugin.settings.colorScheme || "arctic");
    this.createView();
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        this.onFileOpen(file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        var _a;
        (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
      })
    );
  }
  async onClose() {
    this.cleanup();
  }
  createView() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("plugin-container");
    this.createHeroSection(container);
    this.createSlidingNavigation(container);
    this.createContentArea(container);
    this.addStyles();
    setTimeout(() => {
      var _a;
      this.refreshData();
      this.switchToTab("metrics", 0);
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        this.onFileOpen(activeFile);
      } else {
        (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
      }
    }, 100);
  }
  createHeroSection(container) {
    const heroSection = container.createEl("div", { cls: "hero-section" });
    heroSection.createEl("h1", { cls: "main-title", text: i18n.t("view.title") });
    const subtitle = heroSection.createEl("p", { cls: "poetic-subtitle" });
    subtitle.innerHTML = i18n.t("view.subtitle");
    const docCount = this.getVisitedDocumentCount();
    this.statusText = heroSection.createEl("div", { cls: "status-text" });
    this.statusText.textContent = i18n.t("view.statusTemplate", { count: docCount.toString() });
    this.actionBar = new ActionBar(heroSection, this.plugin, {
      onContinueReading: () => this.continueReading(),
      onGetSmartRecommendations: () => this.getSmartRecommendations(),
      onRefreshData: () => this.refreshData(),
      onRandomRoaming: () => this.randomRoaming(),
      onAddCurrentToRoaming: () => this.addCurrentToRoaming(),
      onRemoveCurrentFromRoaming: () => this.removeCurrentFromRoaming()
    });
  }
  createSlidingNavigation(container) {
    this.navigationTabs = new NavigationTabs(
      container,
      (tabId, index) => this.switchToTab(tabId, index),
      "metrics"
    );
  }
  createContentArea(container) {
    const content = container.createEl("div", { cls: "content-area" });
    this.createMetricsSection(content);
    this.createRecommendationsSection(content);
    this.createRankingSection(content);
    this.createVisualizationSection(content);
    this.hideAllSections();
  }
  createMetricsSection(container) {
    const metricsSection = container.createEl("div", { cls: "metrics-section", attr: { "data-section": "metrics" } });
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      const metrics = this.plugin.getDocumentMetrics(activeFile);
      this.documentMetricsDisplay = new DocumentMetricsDisplay(
        metricsSection,
        this.plugin,
        activeFile,
        metrics,
        () => this.refreshData()
        // 当指标更新时刷新数据
      );
      this.documentMetricsDisplay.render();
    } else {
      metricsSection.createEl("p", { text: i18n.t("metrics.noFileOpen"), cls: "empty-message" });
    }
  }
  createRecommendationsSection(container) {
    const recommendationsSection = container.createEl("div", { cls: "recommendations-section", attr: { "data-section": "recommendations" } });
    this.recommendationList = new RecommendationList(recommendationsSection, this.plugin, {
      onOpenDocument: (file) => this.openDocument(file),
      onEditMetrics: (file, metrics) => {
      }
      // 空实现，保留接口兼容性
    });
    this.recommendationList.render([]);
  }
  createRankingSection(container) {
    const rankingSection = container.createEl("div", { cls: "ranking-section", attr: { "data-section": "ranking" } });
    this.rankingList = new RankingList(rankingSection, this.plugin, {
      onOpenDocument: (file) => this.openDocument(file),
      onEditMetrics: (file, metrics) => {
      }
      // 空实现，保留接口兼容性
    });
    this.rankingList.refresh();
  }
  createVisualizationSection(container) {
    const visualizationSection = container.createEl("div", { cls: "visualization-section", attr: { "data-section": "visualization" } });
    this.priorityVisualization = new PriorityVisualization(
      visualizationSection,
      this.plugin,
      (file) => this.openDocument(file)
    );
    this.priorityVisualization.refresh();
  }
  async switchToTab(tabId, index) {
    var _a;
    this.currentActiveTab = tabId;
    this.hideAllSections();
    this.showSection(tabId);
    (_a = this.navigationTabs) == null ? void 0 : _a.setActiveTab(tabId);
    switch (tabId) {
      case "metrics":
        this.updateMetricsSection();
        break;
      case "recommendations":
        await this.updateRecommendationsSection();
        break;
      case "ranking":
        this.updateRankingSection();
        break;
      case "visualization":
        this.updateVisualizationSection();
        break;
    }
  }
  hideAllSections() {
    const sections = this.containerEl.querySelectorAll("[data-section]");
    sections.forEach((section) => {
      section.style.display = "none";
    });
  }
  showSection(sectionId) {
    const section = this.containerEl.querySelector(`[data-section="${sectionId}"]`);
    if (section) {
      section.style.display = "block";
    }
  }
  updateMetricsSection() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && this.documentMetricsDisplay) {
      const metrics = this.plugin.getDocumentMetrics(activeFile);
      this.documentMetricsDisplay.updateMetrics(activeFile, metrics);
    }
  }
  async updateRecommendationsSection() {
    if (this.recommendationList) {
      try {
        const recommendations = await this.plugin.recommendationService.getRecommendations();
        this.recommendationList.renderWithScores(recommendations);
      } catch (error) {
        console.error("\u66F4\u65B0\u63A8\u8350\u90E8\u5206\u5931\u8D25:", error);
        const recommendations = this.plugin.getRecommendedDocuments(10);
        this.recommendationList.render(recommendations);
      }
    }
  }
  updateRankingSection() {
    if (this.rankingList) {
      this.rankingList.refresh();
    }
  }
  updateVisualizationSection() {
    if (this.priorityVisualization) {
      this.priorityVisualization.refresh();
    }
  }
  // 业务逻辑方法
  async onFileOpen(file) {
    var _a, _b, _c;
    if (!file)
      return;
    try {
      console.log(`\u6587\u4EF6\u5207\u6362\u5230: ${file.path} (\u5F53\u524D\u6807\u7B7E: ${this.currentActiveTab})`);
      const now = Date.now();
      if (this.lastProcessedFile === file.path && now - this.lastProcessedTime < 3e3) {
        console.log("\u8DF3\u8FC7\u91CD\u590D\u7684\u6587\u4EF6\u6253\u5F00\u4E8B\u4EF6\uFF08\u9632\u6296\uFF09");
        this.currentFile = file;
        this.currentMetrics = this.plugin.getDocumentMetrics(file);
        if (this.currentActiveTab === "metrics") {
          this.updateMetricsSection();
        }
        (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
        return;
      }
      this.currentFile = file;
      this.currentMetrics = this.plugin.getDocumentMetrics(file);
      if (this.plugin.settings.roamingDocs.includes(file.path)) {
        await this.plugin.updateDocumentMetrics(file, {
          lastVisited: Date.now(),
          visitCount: (((_b = this.currentMetrics) == null ? void 0 : _b.visitCount) || 0) + 1
        });
        this.currentMetrics = this.plugin.getDocumentMetrics(file);
        this.lastProcessedFile = file.path;
        this.lastProcessedTime = now;
      }
      if (this.currentActiveTab === "metrics") {
        this.updateMetricsSection();
      }
      (_c = this.actionBar) == null ? void 0 : _c.updateButtonStates();
    } catch (error) {
      console.error("\u6587\u4EF6\u5207\u6362\u5904\u7406\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.fileSwitchError"));
    }
  }
  async continueReading() {
    var _a;
    try {
      const validRoamingFiles = this.plugin.getValidRoamingFiles();
      if (validRoamingFiles.length === 0) {
        new import_obsidian4.Notice(i18n.t("view.actionBar.noDocuments"));
        return;
      }
      const weightedFiles = validRoamingFiles.map((file) => {
        const metrics = this.plugin.getDocumentMetrics(file);
        const priority = this.calculatePriority(metrics);
        return { file, weight: Math.max(0.1, priority) };
      });
      const totalWeight = weightedFiles.reduce((sum, item) => sum + item.weight, 0);
      let random = Math.random() * totalWeight;
      let selectedFile = null;
      for (const { file, weight } of weightedFiles) {
        random -= weight;
        if (random <= 0) {
          selectedFile = file;
          break;
        }
      }
      if (selectedFile) {
        await this.openDocument(selectedFile);
        const selectedWeight = ((_a = weightedFiles.find((item) => item.file.path === selectedFile.path)) == null ? void 0 : _a.weight) || 0.1;
        const selectionProbability = selectedWeight / totalWeight * 100;
        new import_obsidian4.Notice(i18n.t("notices.selectionProbability", {
          filename: selectedFile.basename,
          probability: selectionProbability.toFixed(1)
        }));
      }
    } catch (error) {
      console.error("\u7EE7\u7EED\u6F2B\u6E38\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.continueFailed"));
    }
  }
  async getSmartRecommendations() {
    try {
      const recommendations = await this.plugin.recommendationService.getRecommendations();
      if (recommendations.length === 0) {
        new import_obsidian4.Notice(i18n.t("recommendations.emptyMessage"));
        return;
      }
      const topRecommendation = recommendations[0];
      const similarity = (topRecommendation.score * 100).toFixed(1);
      await this.openDocument(topRecommendation.file);
      new import_obsidian4.Notice(i18n.t("recommendations.smartJumpNotice", {
        filename: topRecommendation.file.basename,
        similarity
      }));
    } catch (error) {
      console.error("\u667A\u80FD\u63A8\u8350\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.smartRecommendationFailed"));
    }
  }
  async refreshData() {
    var _a;
    this.updateStatusText();
    this.updateMetricsSection();
    await this.updateRecommendationsSection();
    this.updateRankingSection();
    this.updateVisualizationSection();
    (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
  }
  /**
   * 刷新整个视图UI（用于语言切换）
   */
  refreshUI() {
    console.log("\u5F00\u59CB\u5237\u65B0UI...");
    const currentTab = this.currentActiveTab;
    console.log(`\u5F53\u524D\u6FC0\u6D3B\u6807\u7B7E: ${currentTab}`);
    this.plugin.applyColorScheme(this.plugin.settings.colorScheme || "arctic");
    this.createView();
    setTimeout(() => {
      console.log(`\u6062\u590D\u6807\u7B7E\u9875: ${currentTab}`);
      const tabIndex = currentTab === "metrics" ? 0 : currentTab === "recommendations" ? 1 : currentTab === "ranking" ? 2 : currentTab === "visualization" ? 3 : 0;
      this.switchToTab(currentTab, tabIndex);
      this.refreshData();
    }, 200);
  }
  updateStatusText() {
    if (this.statusText) {
      const docCount = this.getVisitedDocumentCount();
      this.statusText.textContent = i18n.t("view.statusTemplate", { count: docCount.toString() });
    }
  }
  async randomRoaming() {
    try {
      const roamingFiles = this.plugin.getValidRoamingFiles();
      if (roamingFiles.length === 0) {
        new import_obsidian4.Notice(i18n.t("view.actionBar.noDocuments"));
        return;
      }
      const randomIndex = Math.floor(Math.random() * roamingFiles.length);
      const randomFile = roamingFiles[randomIndex];
      await this.openDocument(randomFile);
      new import_obsidian4.Notice(i18n.t("notices.randomRoaming", { filename: randomFile.basename }));
    } catch (error) {
      console.error("\u968F\u673A\u6F2B\u6E38\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.randomRoamingFailed"));
    }
  }
  async addCurrentToRoaming() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice(i18n.t("notices.noActiveFile"));
      return;
    }
    try {
      if (activeFile.extension !== "md") {
        new import_obsidian4.Notice(i18n.t("notices.onlyMarkdownFiles"));
        return;
      }
      if (this.plugin.settings.roamingDocs.includes(activeFile.path)) {
        new import_obsidian4.Notice(i18n.t("view.actionBar.alreadyInRoaming"));
        return;
      }
      this.plugin.settings.roamingDocs.push(activeFile.path);
      const fileService = this.plugin.fileManagementService;
      const defaultMetrics = fileService.createDefaultMetricsForFile(activeFile);
      await this.plugin.updateDocumentMetrics(activeFile, defaultMetrics);
      await this.plugin.saveSettings();
      new import_obsidian4.Notice(i18n.t("notices.addedToRoaming", { filename: activeFile.basename }));
      this.refreshData();
      (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
    } catch (error) {
      console.error("\u52A0\u5165\u6F2B\u6E38\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  async removeCurrentFromRoaming() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice(i18n.t("notices.noActiveFile"));
      return;
    }
    try {
      const index = this.plugin.settings.roamingDocs.indexOf(activeFile.path);
      if (index > -1) {
        this.plugin.settings.roamingDocs.splice(index, 1);
        await this.plugin.saveSettings();
        new import_obsidian4.Notice(i18n.t("notices.removedFromRoaming", { filename: activeFile.basename }));
        this.refreshData();
        (_a = this.actionBar) == null ? void 0 : _a.updateButtonStates();
      }
    } catch (error) {
      console.error("\u79FB\u9664\u6F2B\u6E38\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  async openDocument(file) {
    try {
      await this.app.workspace.getLeaf().openFile(file);
    } catch (error) {
      console.error("\u6253\u5F00\u6587\u6863\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.documentOpenFailed"));
    }
  }
  async editDocumentMetrics(file, currentMetrics) {
    try {
      const modal = new DocumentMetricsModal(
        this.app,
        file,
        currentMetrics,
        this.plugin.settings.customMetrics,
        async (updatedMetrics) => {
          await this.plugin.updateDocumentMetrics(file, updatedMetrics);
          new import_obsidian4.Notice(i18n.t("notices.settingsSaved"));
          this.refreshData();
        },
        async (realTimeMetrics) => {
          await this.updateDocumentMetricsRealTime(file, realTimeMetrics);
        }
      );
      modal.open();
    } catch (error) {
      console.error("\u7F16\u8F91\u6587\u6863\u5F97\u5206\u5931\u8D25:", error);
      new import_obsidian4.Notice(i18n.t("notices.editMetricsFailed"));
    }
  }
  async updateDocumentMetricsRealTime(file, realTimeMetrics) {
    try {
      this.plugin.settings.documentMetrics[file.path] = {
        ...realTimeMetrics,
        lastVisited: Date.now()
      };
      this.updateRankingSection();
    } catch (error) {
      console.warn("\u5B9E\u65F6\u6307\u6807\u66F4\u65B0\u5931\u8D25:", error);
    }
  }
  calculatePriority(metrics) {
    return this.plugin.documentScoringService.calculatePriority(metrics, this.plugin.settings.customMetrics);
  }
  getVisitedDocumentCount() {
    return this.plugin.settings.roamingDocs.length;
  }
  addStyles() {
  }
  cleanup() {
    this.actionBar = null;
    this.documentMetricsDisplay = null;
    this.navigationTabs = null;
    this.rankingList = null;
    this.recommendationList = null;
    this.priorityVisualization = null;
  }
};

// src/utils/CacheManager.ts
var CacheManager = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.defaultTTL = 5 * 60 * 1e3;
    // 5 minutes default TTL
    this.maxCacheSize = 1e3;
  }
  /**
   * Get value from cache
   */
  get(key) {
    const entry = this.cache.get(key);
    if (!entry)
      return null;
    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      return null;
    }
    return entry.value;
  }
  /**
   * Set value in cache with optional TTL
   */
  set(key, value, ttl = this.defaultTTL) {
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldest();
    }
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      expires: Date.now() + ttl
    });
  }
  /**
   * Delete cache entry
   */
  delete(key) {
    return this.cache.delete(key);
  }
  /**
   * Clear all cache entries
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Evict expired entries
   */
  evictExpired() {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expires) {
        this.cache.delete(key);
      }
    }
  }
  /**
   * Evict oldest entries
   */
  evictOldest() {
    const entries = Array.from(this.cache.entries());
    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
    const toDelete = entries.slice(0, Math.floor(this.maxCacheSize * 0.1));
    toDelete.forEach(([key]) => this.cache.delete(key));
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const now = Date.now();
    let expired = 0;
    for (const entry of this.cache.values()) {
      if (now > entry.expires) {
        expired++;
      }
    }
    return {
      size: this.cache.size,
      expired
    };
  }
};
var FileContentCache = class {
  constructor(app) {
    this.cache = new CacheManager();
    this.app = app;
  }
  /**
   * Get file content with caching
   */
  async getFileContent(file, maxLength = 5e4) {
    const cacheKey = `content:${file.path}:${file.stat.mtime}`;
    const cached = this.cache.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const text = await this.app.vault.read(file);
      const truncatedText = text.length > maxLength ? text.substr(0, maxLength) : text;
      const tokens = this.tokenize(truncatedText);
      const content = {
        text: truncatedText,
        tokens,
        lastModified: file.stat.mtime
      };
      this.cache.set(cacheKey, content, 10 * 60 * 1e3);
      return content;
    } catch (error) {
      console.error("Error reading file:", file.path, error);
      return {
        text: "",
        tokens: [],
        lastModified: 0
      };
    }
  }
  /**
   * Simple tokenization for caching
   */
  tokenize(text) {
    return text.toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g, " ").split(/\s+/).filter((token) => token.length > 2);
  }
  /**
   * Clear cache for specific file
   */
  clearFileCache(file) {
    const stats = this.cache.getStats();
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return this.cache.getStats();
  }
};
var VectorCache = class {
  constructor() {
    this.cache = new CacheManager();
  }
  /**
   * Get cached vector
   */
  getVector(key) {
    return this.cache.get(key);
  }
  /**
   * Cache a vector
   */
  setVector(key, vector) {
    const magnitude = Math.sqrt(
      Array.from(vector.values()).reduce((sum, val) => sum + val * val, 0)
    );
    const documentVector = {
      vector: new Map(vector),
      // Create copy
      magnitude
    };
    this.cache.set(key, documentVector, 15 * 60 * 1e3);
  }
  /**
   * Calculate cosine similarity using cached magnitudes
   */
  cosineSimilarity(vectorA, vectorB) {
    if (vectorA.magnitude === 0 || vectorB.magnitude === 0)
      return 0;
    let dotProduct = 0;
    const smallerVector = vectorA.vector.size < vectorB.vector.size ? vectorA.vector : vectorB.vector;
    const largerVector = vectorA.vector.size >= vectorB.vector.size ? vectorA.vector : vectorB.vector;
    for (const [term, valueA] of smallerVector) {
      const valueB = largerVector.get(term) || 0;
      dotProduct += valueA * valueB;
    }
    return dotProduct / (vectorA.magnitude * vectorB.magnitude);
  }
  /**
   * Clear all cached vectors
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return this.cache.getStats();
  }
};

// src/services/RecommendationService.ts
var RecommendationService = class {
  constructor(app, settings) {
    this.documentCache = /* @__PURE__ */ new Map();
    this.app = app;
    this.settings = settings;
    this.fileCache = new FileContentCache(app);
    this.vectorCache = new VectorCache();
  }
  /**
   * Get recommended documents based on Text Cosine Similarity
   */
  async getRecommendations(excludeFile) {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const roamingFiles = files.filter(
        (file) => SharedUtils.shouldIncludeFile(file, this.settings.excludedPaths) && file !== excludeFile && this.settings.roamingDocs.includes(file.path)
        // Only include roaming documents
      );
      if (roamingFiles.length === 0) {
        return [];
      }
      const currentFile = excludeFile || this.app.workspace.getActiveFile();
      if (!currentFile) {
        return this.getPriorityBasedRecommendations(roamingFiles);
      }
      const maxCandidates = Math.min(roamingFiles.length, this.settings.recommendationSettings.maxCandidates);
      const limitedRoamingFiles = roamingFiles.slice(0, maxCandidates);
      const similarityPromises = limitedRoamingFiles.filter((roamingFile) => roamingFile.path !== currentFile.path).map(async (roamingFile) => {
        try {
          const similarity = await this.calculateTextSimilarityFast(currentFile, roamingFile);
          return { file: roamingFile, score: similarity };
        } catch (error) {
          return null;
        }
      });
      const similarityResults = await Promise.all(similarityPromises);
      const similarityScores = similarityResults.filter((result2) => result2 && result2.score > 0).map((result2) => result2);
      similarityScores.sort((a, b) => b.score - a.score);
      if (similarityScores.length === 0) {
        return this.getPriorityBasedRecommendations(roamingFiles);
      }
      const topK = Math.min(this.settings.recommendationSettings.topK, similarityScores.length);
      const result = similarityScores.slice(0, topK);
      return result;
    } catch (error) {
      console.error("\u667A\u80FD\u63A8\u8350\u7B97\u6CD5\u51FA\u9519:", error);
      return [];
    }
  }
  /**
   * 去重逻辑 - 根据文档ID移除重复项
   */
  deduplicateRecommendations(recommendations) {
    const seenFiles = /* @__PURE__ */ new Map();
    const duplicates = [];
    console.log(`\u5F00\u59CB\u53BB\u91CD\uFF0C\u8F93\u5165\u6587\u6863\u6570\u91CF: ${recommendations.length}`);
    for (const recommendation of recommendations) {
      const fileId = recommendation.file.path;
      if (!seenFiles.has(fileId)) {
        seenFiles.set(fileId, recommendation);
      } else {
        const existing = seenFiles.get(fileId);
        if (recommendation.score > existing.score) {
          console.log(`\u53BB\u91CD: \u53D1\u73B0\u91CD\u590D\u6587\u6863 ${recommendation.file.basename}\uFF0C\u4FDD\u7559\u66F4\u9AD8\u5206\u6570 ${recommendation.score.toFixed(4)} > ${existing.score.toFixed(4)}`);
          seenFiles.set(fileId, recommendation);
        } else {
          console.log(`\u53BB\u91CD: \u53D1\u73B0\u91CD\u590D\u6587\u6863 ${recommendation.file.basename}\uFF0C\u4FDD\u7559\u539F\u5206\u6570 ${existing.score.toFixed(4)} > ${recommendation.score.toFixed(4)}`);
        }
        duplicates.push(fileId);
      }
    }
    const uniqueRecommendations = Array.from(seenFiles.values());
    console.log(`\u53BB\u91CD\u5B8C\u6210: \u53D1\u73B0 ${duplicates.length} \u4E2A\u91CD\u590D\u9879\uFF0C\u6700\u7EC8 ${uniqueRecommendations.length} \u4E2A\u552F\u4E00\u6587\u6863`);
    return uniqueRecommendations;
  }
  /**
   * 基于优先级的简单推荐（回退方案）
   */
  getPriorityBasedRecommendations(roamingFiles) {
    const priorityRecs = roamingFiles.sort((a, b) => {
      const aMetrics = this.getDocumentMetrics(a);
      const bMetrics = this.getDocumentMetrics(b);
      return bMetrics.priority - aMetrics.priority;
    }).slice(0, this.settings.recommendationSettings.topK).map((file) => ({
      file,
      score: this.getDocumentMetrics(file).priority / 10
    }));
    return this.deduplicateRecommendations(priorityRecs);
  }
  /**
   * 快速计算两个文档之间的文本相似度（优化版）
   */
  async calculateTextSimilarityFast(file1, file2) {
    try {
      const cacheKey = `${file1.path}-${file2.path}`;
      const cached = this.vectorCache.getVector(cacheKey);
      if (cached !== null) {
        return cached.vector.get("similarity") || 0;
      }
      const [content1, content2] = await Promise.all([
        this.extractSimpleTextContent(file1),
        this.extractSimpleTextContent(file2)
      ]);
      if (!content1 || !content2 || content1.length < 20 || content2.length < 20) {
        return 0;
      }
      const limitedContent1 = content1.substring(0, 1e3);
      const limitedContent2 = content2.substring(0, 1e3);
      const tokens1 = this.simpleTokenize(limitedContent1);
      const tokens2 = this.simpleTokenize(limitedContent2);
      if (tokens1.length === 0 || tokens2.length === 0) {
        return 0;
      }
      const freq1 = this.calculateWordFrequency(tokens1);
      const freq2 = this.calculateWordFrequency(tokens2);
      const similarity = this.cosineSimilarityFromFreq(freq1, freq2);
      const validSimilarity = !isFinite(similarity) || isNaN(similarity) ? 0 : Math.max(0, Math.min(1, similarity));
      const similarityVector = /* @__PURE__ */ new Map();
      similarityVector.set("similarity", validSimilarity);
      this.vectorCache.setVector(cacheKey, similarityVector);
      return validSimilarity;
    } catch (error) {
      return 0;
    }
  }
  /**
   * 计算两个文档之间的文本余弦相似度（详细版）
   */
  async calculateTextSimilarity(file1, file2) {
    try {
      console.log(`\u5F00\u59CB\u8BA1\u7B97 ${file1.basename} \u4E0E ${file2.basename} \u7684\u6587\u672C\u76F8\u4F3C\u5EA6...`);
      const content1 = await this.extractSimpleTextContent(file1);
      const content2 = await this.extractSimpleTextContent(file2);
      console.log(`\u6587\u68631\u5185\u5BB9\u957F\u5EA6: ${content1.length}, \u6587\u68632\u5185\u5BB9\u957F\u5EA6: ${content2.length}`);
      if (!content1 || !content2 || content1.length < 10 || content2.length < 10) {
        console.log("\u6587\u6863\u5185\u5BB9\u592A\u77ED\uFF0C\u8DF3\u8FC7\u76F8\u4F3C\u5EA6\u8BA1\u7B97");
        return 0;
      }
      const tokens1 = this.simpleTokenize(content1);
      const tokens2 = this.simpleTokenize(content2);
      console.log(`\u6587\u68631\u8BCD\u6570: ${tokens1.length}, \u6587\u68632\u8BCD\u6570: ${tokens2.length}`);
      if (tokens1.length === 0 || tokens2.length === 0) {
        console.log("\u5206\u8BCD\u7ED3\u679C\u4E3A\u7A7A\uFF0C\u8DF3\u8FC7\u76F8\u4F3C\u5EA6\u8BA1\u7B97");
        return 0;
      }
      const freq1 = this.calculateWordFrequency(tokens1);
      const freq2 = this.calculateWordFrequency(tokens2);
      const similarity = this.cosineSimilarityFromFreq(freq1, freq2);
      const validSimilarity = !isFinite(similarity) || isNaN(similarity) ? 0 : Math.max(0, Math.min(1, similarity));
      console.log(`\u6700\u7EC8\u76F8\u4F3C\u5EA6: ${validSimilarity.toFixed(4)}`);
      return validSimilarity;
    } catch (error) {
      console.error(`\u8BA1\u7B97\u6587\u672C\u76F8\u4F3C\u5EA6\u5931\u8D25:`, error);
      return 0;
    }
  }
  /**
   * 简化的文本内容提取
   */
  async extractSimpleTextContent(file) {
    try {
      const content = await this.app.vault.read(file);
      return content.replace(/```[\s\S]*?```/g, "").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[[^\]]*\]\([^)]+\)/g, "").replace(/#{1,6}\s+/g, " ").replace(/\*\*([^\*]+)\*\*/g, "$1").replace(/\*([^\*]+)\*/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^\s*>\s+/gm, "").replace(/[^\w\s\u4e00-\u9fff]/g, " ").replace(/\s+/g, " ").trim();
    } catch (error) {
      console.error(`\u63D0\u53D6 ${file.basename} \u5185\u5BB9\u5931\u8D25:`, error);
      return "";
    }
  }
  /**
   * 简化的分词方法
   */
  simpleTokenize(text) {
    const tokens = [];
    const lowerText = text.toLowerCase();
    for (let i = 0; i < lowerText.length; i++) {
      const char = lowerText[i];
      if (/[\u4e00-\u9fff]/.test(char)) {
        tokens.push(char);
      } else if (/[a-zA-Z]/.test(char)) {
        let word = char;
        while (i + 1 < lowerText.length && /[a-zA-Z]/.test(lowerText[i + 1])) {
          i++;
          word += lowerText[i];
        }
        if (word.length > 1) {
          tokens.push(word);
        }
      }
    }
    const stopWords = /* @__PURE__ */ new Set(["\u7684", "\u4E86", "\u5728", "\u662F", "\u6211", "\u6709", "\u548C", "\u5C31", "\u4E0D", "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for"]);
    return tokens.filter((token) => !stopWords.has(token) && token.length > 0);
  }
  /**
   * 计算词频
   */
  calculateWordFrequency(tokens) {
    const frequency = /* @__PURE__ */ new Map();
    for (const token of tokens) {
      frequency.set(token, (frequency.get(token) || 0) + 1);
    }
    return frequency;
  }
  /**
   * 从词频计算余弦相似度
   */
  cosineSimilarityFromFreq(freq1, freq2) {
    const allWords = /* @__PURE__ */ new Set([...freq1.keys(), ...freq2.keys()]);
    if (allWords.size === 0) {
      return 0;
    }
    let dotProduct = 0;
    let magnitude1 = 0;
    let magnitude2 = 0;
    for (const word of allWords) {
      const f1 = freq1.get(word) || 0;
      const f2 = freq2.get(word) || 0;
      dotProduct += f1 * f2;
      magnitude1 += f1 * f1;
      magnitude2 += f2 * f2;
    }
    magnitude1 = Math.sqrt(magnitude1);
    magnitude2 = Math.sqrt(magnitude2);
    if (magnitude1 === 0 || magnitude2 === 0 || !isFinite(magnitude1) || !isFinite(magnitude2)) {
      return 0;
    }
    const similarity = dotProduct / (magnitude1 * magnitude2);
    if (!isFinite(similarity) || isNaN(similarity)) {
      return 0;
    }
    return Math.max(0, Math.min(1, similarity));
  }
  /**
   * Calculate TF-IDF similarity scores between candidates and anchors
   */
  async calculateSimilarityScores(candidates, anchors) {
    try {
      const { vocabulary, documentFrequencies, totalDocs } = await this.buildVocabulary([...candidates, ...anchors]);
      const anchorVectors = [];
      for (const anchor of anchors) {
        const vector = await this.getOrCalculateTfIdfVector(anchor, vocabulary, documentFrequencies, totalDocs);
        anchorVectors.push(vector);
      }
      const scores = [];
      for (const candidate of candidates) {
        const candidateVector = await this.getOrCalculateTfIdfVector(candidate, vocabulary, documentFrequencies, totalDocs);
        let totalSimilarity = 0;
        let validAnchorCount = 0;
        for (let i = 0; i < anchors.length; i++) {
          const similarity = this.cosineSimilarity(candidateVector, anchorVectors[i]);
          if (similarity > 0) {
            totalSimilarity += similarity;
            validAnchorCount++;
          }
        }
        const avgSimilarity = validAnchorCount > 0 ? totalSimilarity / validAnchorCount : 0;
        const metrics = this.getDocumentMetrics(candidate);
        const priorityScore = SharedUtils.calculatePriority(metrics, this.settings.metricWeights, this.settings.customMetrics) / 50;
        const daysSinceVisit = metrics.lastVisited ? (Date.now() - metrics.lastVisited) / (1e3 * 60 * 60 * 24) : 999;
        const recencyScore = Math.min(daysSinceVisit / 30, 1);
        const visitScore = Math.max(0, 1 - metrics.visitCount * 0.1);
        const finalScore = avgSimilarity * 0.4 + priorityScore * 0.3 + recencyScore * 0.2 + visitScore * 0.1;
        scores.push({ file: candidate, score: finalScore });
      }
      scores.sort((a, b) => b.score - a.score);
      return scores;
    } catch (error) {
      console.error("Error calculating similarity scores:", error);
      return candidates.map((file) => {
        const metrics = this.settings.documentMetrics[file.path] || {
          lastVisited: Date.now(),
          visitCount: 0
        };
        const priority = SharedUtils.calculatePriority(metrics, this.settings.metricWeights, this.settings.customMetrics);
        return { file, score: priority / 10 };
      });
    }
  }
  /**
   * Build vocabulary and calculate document frequencies
   */
  async buildVocabulary(files) {
    const vocabulary = /* @__PURE__ */ new Set();
    const documentFrequencies = /* @__PURE__ */ new Map();
    const totalDocs = files.length;
    for (const file of files) {
      const tokens = await this.getDocumentTokens(file);
      const uniqueTokens = new Set(tokens);
      for (const token of uniqueTokens) {
        vocabulary.add(token);
        documentFrequencies.set(token, (documentFrequencies.get(token) || 0) + 1);
      }
    }
    return { vocabulary, documentFrequencies, totalDocs };
  }
  /**
   * Get or calculate TF-IDF vector with caching
   */
  async getOrCalculateTfIdfVector(file, vocabulary, documentFrequencies, totalDocs) {
    const cacheKey = `tfidf:${file.path}:${file.stat.mtime}`;
    const cached = this.vectorCache.getVector(cacheKey);
    if (cached) {
      return cached.vector;
    }
    const tokens = await this.getDocumentTokens(file);
    const vector = this.calculateTfIdfVector(tokens, vocabulary, documentFrequencies, totalDocs);
    this.vectorCache.setVector(cacheKey, vector);
    return vector;
  }
  /**
   * Get document tokens with caching
   */
  async getDocumentTokens(file) {
    const cacheKey = `${file.path}-${file.stat.mtime}`;
    const cached = this.documentCache.get(cacheKey);
    if (cached) {
      return cached.tokens;
    }
    const content = await this.extractTextContent(file);
    const tokens = this.tokenize(content);
    this.documentCache.set(cacheKey, { content, tokens });
    return tokens;
  }
  async getAnchorDocuments(files) {
    const anchors = [];
    const recentVisited = files.filter(
      (file) => this.settings.roamingDocs.includes(file.path)
    );
    recentVisited.sort((a, b) => {
      const aTime = this.getDocumentMetrics(a).lastVisited || 0;
      const bTime = this.getDocumentMetrics(b).lastVisited || 0;
      return bTime - aTime;
    });
    const recentAnchors = recentVisited.slice(0, this.settings.recommendationSettings.recentCount);
    const withVisitCount = files.map((file) => ({
      file,
      visitCount: this.getDocumentMetrics(file).visitCount
    }));
    withVisitCount.sort((a, b) => b.visitCount - a.visitCount);
    const topVisitedAnchors = withVisitCount.slice(0, this.settings.recommendationSettings.topCount).map((item) => item.file);
    const allAnchors = [...recentAnchors, ...topVisitedAnchors];
    for (const file of allAnchors) {
      if (!anchors.some((a) => a.path === file.path)) {
        anchors.push(file);
      }
    }
    return anchors;
  }
  calculateTfIdfVector(tokens, vocabulary, documentFrequencies, totalDocs) {
    const vector = /* @__PURE__ */ new Map();
    const termFrequencies = /* @__PURE__ */ new Map();
    for (const token of tokens) {
      termFrequencies.set(token, (termFrequencies.get(token) || 0) + 1);
    }
    let vectorSum = 0;
    for (const [term, tf] of termFrequencies) {
      const df = documentFrequencies.get(term) || 1;
      const idf = Math.log(totalDocs / df);
      const tfidf = tf / tokens.length * idf;
      vector.set(term, tfidf);
      vectorSum += tfidf * tfidf;
    }
    const magnitude = Math.sqrt(vectorSum);
    if (magnitude > 0) {
      for (const [term, value] of vector) {
        vector.set(term, value / magnitude);
      }
    }
    return vector;
  }
  cosineSimilarity(vectorA, vectorB) {
    let dotProduct = 0;
    let magnitudeA = 0;
    let magnitudeB = 0;
    for (const [term, valueA] of vectorA) {
      const valueB = vectorB.get(term) || 0;
      if (valueB !== 0) {
        dotProduct += valueA * valueB;
      }
    }
    for (const valueA of vectorA.values()) {
      magnitudeA += valueA * valueA;
    }
    magnitudeA = Math.sqrt(magnitudeA);
    for (const valueB of vectorB.values()) {
      magnitudeB += valueB * valueB;
    }
    magnitudeB = Math.sqrt(magnitudeB);
    if (magnitudeA === 0 || magnitudeB === 0)
      return 0;
    return dotProduct / (magnitudeA * magnitudeB);
  }
  async extractTextContent(file) {
    const content = await this.app.vault.read(file);
    const cleanContent = content.replace(/```[\s\S]*?```/g, " ").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[[^\]]*\]\([^)]+\)/g, " ").replace(/^\s*>\s+/gm, " ").replace(/\n{3,}/g, "\n\n").trim();
    const titleMatch = cleanContent.match(/^#{1,6}\s+(.+)$/m);
    const title = titleMatch ? titleMatch[1] : "";
    const paragraphs = cleanContent.split(/\n\n+/).filter((p) => p.trim().length > 5).map(
      (p) => p.replace(/#{1,6}\s+/g, "").replace(/\*\*([^\*]+)\*\*/g, "$1").replace(/\*([^\*]+)\*/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").trim()
    ).filter((p) => p.length > 3);
    const maxParagraphs = this.settings.recommendationSettings.maxParagraphs;
    let selectedTexts = [];
    if (title) {
      selectedTexts.push(title);
    }
    if (paragraphs.length > 0) {
      const sampleSize = Math.min(maxParagraphs - 1, paragraphs.length);
      if (sampleSize === 1) {
        selectedTexts.push(paragraphs[0]);
      } else if (sampleSize === 2) {
        selectedTexts.push(paragraphs[0]);
        selectedTexts.push(paragraphs[paragraphs.length - 1]);
      } else {
        selectedTexts.push(paragraphs[0]);
        const middleIndex = Math.floor(paragraphs.length / 2);
        selectedTexts.push(paragraphs[middleIndex]);
        selectedTexts.push(paragraphs[paragraphs.length - 1]);
      }
    }
    return selectedTexts.join(" ");
  }
  tokenize(text) {
    const tokens = [];
    const lowerText = text.toLowerCase();
    for (let i = 0; i < lowerText.length; i++) {
      const char = lowerText[i];
      if (/[\u4e00-\u9fff]/.test(char)) {
        tokens.push(char);
      } else if (/[a-zA-Z]/.test(char)) {
        let word = char;
        while (i + 1 < lowerText.length && /[a-zA-Z]/.test(lowerText[i + 1])) {
          i++;
          word += lowerText[i];
        }
        if (word.length > 1) {
          tokens.push(word);
        }
      }
    }
    return tokens.filter((token) => !this.isStopWord(token));
  }
  isStopWord(token) {
    const stopWords = /* @__PURE__ */ new Set([
      // English
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "being",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those",
      "i",
      "you",
      "he",
      "she",
      "it",
      "we",
      "they",
      "what",
      "which",
      "who",
      "when",
      "where",
      "why",
      "how",
      "all",
      "any",
      "both",
      "each",
      "few",
      "more",
      "most",
      "other",
      "some",
      "such",
      "no",
      "nor",
      "not",
      "only",
      "own",
      "same",
      "so",
      "than",
      "too",
      "very",
      "just",
      // Chinese
      "\u7684",
      "\u4E86",
      "\u5728",
      "\u662F",
      "\u6211",
      "\u6709",
      "\u548C",
      "\u5C31",
      "\u4E0D",
      "\u4EBA",
      "\u90FD",
      "\u4E00",
      "\u4E00\u4E2A",
      "\u4E0A",
      "\u4E5F",
      "\u5F88",
      "\u5230",
      "\u8BF4",
      "\u8981",
      "\u53BB",
      "\u4F60",
      "\u4F1A",
      "\u7740",
      "\u6CA1\u6709",
      "\u770B",
      "\u597D",
      "\u81EA\u5DF1",
      "\u8FD9",
      "\u90A3",
      "\u91CC",
      "\u5C31\u662F",
      "\u8FD8",
      "\u628A",
      "\u6BD4",
      "\u4ECE",
      "\u88AB",
      "\u672C",
      "\u4E2A",
      "\u4E2D",
      "\u5927",
      "\u4E3A",
      "\u6765",
      "\u4EE5",
      "\u65F6",
      "\u548C",
      "\u7528",
      "\u4E0B",
      "\u800C",
      "\u53CA",
      "\u4E0E",
      "\u5176",
      "\u6216",
      "\u4F46",
      "\u5982",
      "\u82E5",
      "\u5219",
      "\u56E0",
      "\u6240\u4EE5",
      "\u5982\u679C",
      "\u867D\u7136",
      "\u5C3D\u7BA1",
      "\u65E0\u8BBA",
      "\u4E0D\u7BA1",
      "\u9664\u4E86",
      "\u9664\u975E",
      "\u76F4\u5230",
      "\u5F53",
      "\u5728...\u65F6\u5019",
      "\u5173\u4E8E",
      "\u5BF9\u4E8E",
      "\u81F3\u4E8E",
      "\u7531\u4E8E",
      "\u56E0\u4E3A",
      "\u6240\u4EE5",
      "\u4EE5\u4FBF",
      "\u4E3A\u4E86",
      "\u6309\u7167",
      "\u6839\u636E",
      "\u4F9D\u636E"
    ]);
    return stopWords.has(token);
  }
  getDocumentMetrics(file) {
    return SharedUtils.getDocumentMetrics(file, this.settings);
  }
  calculatePriorityScore(metrics) {
    return SharedUtils.calculatePriority(metrics, this.settings.metricWeights, this.settings.customMetrics);
  }
};

// src/models/Settings.ts
var COLOR_SCHEMES = [
  {
    id: "arctic",
    name: { en: "Arctic", zh: "\u6781\u5730" },
    primaryColor: "#a855f7",
    accentColor: "#8b5cf6",
    bgGradient: "linear-gradient(135deg, #faf5ff 0%, #ede9fe 100%)",
    cardBg: "rgba(255, 255, 255, 0.9)",
    textMain: "#1e293b",
    textSecondary: "#64748b"
  },
  {
    id: "forest",
    name: { en: "Forest", zh: "\u68EE\u6797" },
    primaryColor: "#27ae60",
    accentColor: "#16a085",
    bgGradient: "linear-gradient(135deg, #f0fff4 0%, #d4f1d4 100%)",
    cardBg: "rgba(255, 255, 255, 0.9)",
    textMain: "#2c3e50",
    textSecondary: "#7f8c8d"
  },
  {
    id: "sunset",
    name: { en: "Sunset", zh: "\u65E5\u843D" },
    primaryColor: "#ff6b6b",
    accentColor: "#ff9f43",
    bgGradient: "linear-gradient(135deg, #fff5f5 0%, #ffe0e0 100%)",
    cardBg: "rgba(255, 255, 255, 0.85)",
    textMain: "#2c3e50",
    textSecondary: "#7f8c8d"
  },
  {
    id: "ocean",
    name: { en: "Ocean", zh: "\u6D77\u6D0B" },
    primaryColor: "#3498db",
    accentColor: "#2980b9",
    bgGradient: "linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%)",
    cardBg: "rgba(255, 255, 255, 0.9)",
    textMain: "#2c3e50",
    textSecondary: "#7f8c8d"
  },
  {
    id: "dark",
    name: { en: "Dark Mode", zh: "\u6DF1\u8272\u6A21\u5F0F" },
    primaryColor: "#ecf0f1",
    accentColor: "#3498db",
    bgGradient: "linear-gradient(135deg, #2c3e50 0%, #34495e 100%)",
    cardBg: "rgba(52, 73, 94, 0.8)",
    textMain: "#ecf0f1",
    textSecondary: "#bdc3c7"
  }
];
var DEFAULT_SETTINGS = {
  excludeVisited: true,
  roamingDocs: [],
  // 手动添加的漫游文档
  documentMetrics: {},
  customMetrics: [
    { id: "importance", name: { en: "Importance", zh: "\u91CD\u8981\u6027" }, weight: 40 },
    { id: "urgency", name: { en: "Urgency", zh: "\u7D27\u6025\u5EA6" }, weight: 30 },
    { id: "completion", name: { en: "Completion", zh: "\u5B8C\u6210\u5EA6" }, weight: 30 }
  ],
  metricWeights: {
    importance: 40,
    urgency: 30,
    completion: 30
  },
  recommendationSettings: {
    recentCount: 5,
    topCount: 5,
    topK: 10,
    maxCandidates: 100,
    maxParagraphs: 5
  },
  excludedPaths: [
    "Templates/**",
    "Scripts/**",
    "Archive/**",
    ".obsidian/**",
    "**/.git/**"
  ],
  maxCandidates: 100,
  language: "en",
  // 默认英语
  colorScheme: "arctic",
  // 默认极地主题
  version: "2.0.0"
  // 当前版本 - 更新版本号表示重大更新
};

// src/services/FileManagementService.ts
var import_obsidian5 = require("obsidian");
var FileManagementService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * 递归获取文件夹中的所有Markdown文件
   */
  async getFilesInFolder(folderPath) {
    const files = [];
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder || !(folder instanceof import_obsidian5.TFolder)) {
      return files;
    }
    const allFiles = this.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file instanceof import_obsidian5.TFile && file.extension === "md" && (file.path.startsWith(folder.path + "/") || file.path === folder.path)) {
        files.push(file);
      }
    }
    return files;
  }
  /**
   * 批量添加文件夹到漫游列表
   */
  async addFoldersToRoaming(folderPaths) {
    let addedCount = 0;
    const MAX_FILES = 1e3;
    for (const folderPath of folderPaths) {
      try {
        const files = await this.getFilesInFolder(folderPath);
        for (const file of files) {
          if (addedCount >= MAX_FILES) {
            new import_obsidian5.Notice(`\u5DF2\u8FBE\u5230\u6700\u5927\u6587\u4EF6\u6570\u91CF\u9650\u5236 (${MAX_FILES})\uFF0C\u505C\u6B62\u6DFB\u52A0\u66F4\u591A\u6587\u4EF6`);
            break;
          }
          if (!this.settings.roamingDocs.includes(file.path)) {
            this.settings.roamingDocs.push(file.path);
            if (!this.settings.documentMetrics[file.path]) {
              this.settings.documentMetrics[file.path] = this.createDefaultMetricsForFile(file);
            }
            addedCount++;
          }
        }
      } catch (error) {
        console.error(`\u6DFB\u52A0\u6587\u4EF6\u5939 ${folderPath} \u5931\u8D25:`, error);
        new import_obsidian5.Notice(`\u6DFB\u52A0\u6587\u4EF6\u5939 ${folderPath} \u5931\u8D25`);
      }
    }
    return addedCount;
  }
  /**
   * 批量添加文件到漫游列表
   */
  async addMultipleFilesToRoaming(files) {
    let addedCount = 0;
    for (const file of files) {
      if (!this.settings.roamingDocs.includes(file.path)) {
        this.settings.roamingDocs.push(file.path);
        if (!this.settings.documentMetrics[file.path]) {
          this.settings.documentMetrics[file.path] = this.createDefaultMetricsForFile(file);
        }
        addedCount++;
      }
    }
    return addedCount;
  }
  /**
   * 获取有效的漫游文档列表
   */
  getValidRoamingFiles() {
    return this.settings.roamingDocs.map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => {
      return file instanceof import_obsidian5.TFile && file.extension === "md";
    });
  }
  /**
   * 获取有效的漫游文档路径列表
   */
  getValidRoamingPaths() {
    return this.getValidRoamingFiles().map((file) => file.path);
  }
  /**
   * 检查文件是否应该被包含
   */
  shouldIncludeFile(file) {
    return SharedUtils.shouldIncludeFile(file, this.settings.excludedPaths);
  }
  /**
   * 获取所有Markdown文件（排除漫游文档）
   */
  getAvailableFilesForRoaming() {
    const allFiles = this.app.vault.getMarkdownFiles();
    const validRoamingPaths = this.getValidRoamingPaths();
    return allFiles.filter(
      (file) => this.shouldIncludeFile(file) && !validRoamingPaths.includes(file.path)
    );
  }
  /**
   * 随机选择一个未访问的文档
   */
  getRandomUnvisitedFile() {
    const availableFiles = this.getAvailableFilesForRoaming();
    if (availableFiles.length === 0) {
      return null;
    }
    const randomIndex = Math.floor(Math.random() * availableFiles.length);
    return availableFiles[randomIndex];
  }
  /**
   * 创建文档的默认指标
   */
  createDefaultMetricsForFile(file) {
    const defaultMetrics = {
      lastVisited: Date.now(),
      visitCount: 0
    };
    for (const metric of this.settings.customMetrics) {
      defaultMetrics[metric.id] = 5;
    }
    return defaultMetrics;
  }
};

// src/services/DocumentScoringService.ts
var DocumentScoringService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * 计算文档的优先级分数
   */
  calculatePriority(metrics, customMetrics) {
    var _a;
    let totalScore = 0;
    let totalWeight = 0;
    for (const metric of customMetrics) {
      const metricValue = (_a = metrics[metric.id]) != null ? _a : 5;
      const metricWeight = this.settings.metricWeights[metric.id] || metric.weight;
      totalScore += metricValue * (metricWeight / 100);
      totalWeight += metricWeight / 100;
    }
    return totalWeight > 0 ? totalScore / totalWeight * 10 : 0;
  }
  /**
   * 获取文档指标（带默认值）
   */
  getDocumentMetrics(file) {
    const filePath = file.path;
    const stored = this.settings.documentMetrics[filePath];
    if (stored) {
      return stored;
    }
    const defaultMetrics = {
      lastVisited: 0,
      visitCount: 0
    };
    for (const metric of this.settings.customMetrics) {
      defaultMetrics[metric.id] = 5;
    }
    return defaultMetrics;
  }
  /**
   * 更新文档指标
   */
  updateDocumentMetrics(file, metrics) {
    const filePath = file.path;
    const currentMetrics = this.getDocumentMetrics(file);
    const updatedMetrics = {
      ...currentMetrics,
      ...metrics,
      lastVisited: Date.now()
    };
    const hasMetricUpdate = Object.keys(metrics).some(
      (key) => key !== "lastVisited" && key !== "visitCount" && metrics[key] !== void 0
    );
    if (hasMetricUpdate) {
      updatedMetrics.visitCount = currentMetrics.visitCount + 1;
    }
    return updatedMetrics;
  }
  /**
   * 验证指标值是否在有效范围内
   */
  validateMetrics(metrics) {
    const validated = {};
    for (const metric of this.settings.customMetrics) {
      if (metrics[metric.id] !== void 0) {
        validated[metric.id] = Math.max(0, Math.min(10, Number(metrics[metric.id])));
      }
    }
    if (metrics.lastVisited !== void 0) {
      validated.lastVisited = Math.max(0, Number(metrics.lastVisited));
    }
    if (metrics.visitCount !== void 0) {
      validated.visitCount = Math.max(0, Math.floor(Number(metrics.visitCount)));
    }
    return validated;
  }
  /**
   * 获取优先级颜色
   */
  getPriorityColor(priority) {
    if (priority >= 8)
      return "#dc3545";
    if (priority >= 6)
      return "#fd7e14";
    if (priority >= 4)
      return "#ffc107";
    if (priority >= 2)
      return "#28a745";
    return "#6c757d";
  }
  /**
   * 获取文档的详细权重分析
   */
  getWeightBreakdown(metrics) {
    const breakdown = [];
    for (const metric of this.settings.customMetrics) {
      const metricValue = metrics[metric.id] || 5;
      const metricWeight = this.settings.metricWeights[metric.id] || metric.weight;
      const normalizedWeight = metricWeight / 100;
      const score = metricValue * normalizedWeight;
      breakdown.push({
        name: i18n.getMetricName(metric),
        value: metricValue,
        weight: metricWeight,
        score
      });
    }
    return breakdown;
  }
  /**
   * 比较两个文档的优先级
   */
  compareDocumentPriority(file1, file2) {
    const metrics1 = this.getDocumentMetrics(file1);
    const metrics2 = this.getDocumentMetrics(file2);
    const priority1 = this.calculatePriority(metrics1, this.settings.customMetrics);
    const priority2 = this.calculatePriority(metrics2, this.settings.customMetrics);
    return priority2 - priority1;
  }
  /**
   * 获取推荐文档（按优先级排序）
   */
  getRecommendedDocuments(files, limit = 10) {
    const documentsWithPriority = files.map((file) => {
      const metrics = this.getDocumentMetrics(file);
      const priority = this.calculatePriority(metrics, this.settings.customMetrics);
      return { file, priority };
    });
    documentsWithPriority.sort((a, b) => b.priority - a.priority);
    return documentsWithPriority.slice(0, limit).map((item) => item.file);
  }
};

// src/settings/CustomMetricsSettings.ts
var import_obsidian6 = require("obsidian");
var CustomMetricsSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  render() {
    if (!this.contentEl) {
      this.contentEl = this.containerEl.createEl("div", { cls: "custom-metrics-settings-content" });
    } else {
      this.contentEl.empty();
    }
    this.contentEl.createEl("h3", { text: i18n.t("settings.customMetrics.title") });
    this.createMetricManagementHeader();
    this.createCustomMetricsList();
  }
  createMetricManagementHeader() {
    new import_obsidian6.Setting(this.contentEl).setName(i18n.t("settings.customMetrics.title")).setDesc(i18n.t("settings.customMetrics.description")).addButton((button) => button.setButtonText("+ " + i18n.t("settings.customMetrics.addMetric")).setCta().onClick(() => this.addNewMetric()));
  }
  createCustomMetricsList() {
    var _a;
    const metricsContainer = this.contentEl.createEl("div", { cls: "custom-metrics-container" });
    metricsContainer.createEl("h4", { text: i18n.t("settings.customMetrics.title") });
    metricsContainer.createEl("p", {
      text: i18n.t("settings.customMetrics.description"),
      cls: "setting-item-description"
    });
    const metricsList = metricsContainer.createEl("div", { cls: "metrics-list" });
    (_a = this.plugin.settings.customMetrics) == null ? void 0 : _a.forEach((metric, index) => {
      this.createMetricSetting(metricsList, metric, index);
    });
  }
  createMetricSetting(container, metric, index) {
    const metricItem = container.createEl("div", { cls: "metric-setting-item" });
    const titleSetting = new import_obsidian6.Setting(metricItem).setName(`${i18n.t("settings.customMetrics.title")} ${index + 1}`).setDesc(`${i18n.t("settings.customMetrics.metricName")}: ${i18n.getMetricName(metric)}`).addButton((button) => button.setButtonText(i18n.t("settings.customMetrics.removeMetric")).setWarning().onClick(() => this.deleteMetric(index)));
    new import_obsidian6.Setting(metricItem).setName("Metric Name (English)").setDesc("Enter the English name for this metric").addText((text) => text.setPlaceholder("e.g., Importance").setValue(metric.name.en || "").onChange(async (value) => {
      const oldId = this.plugin.settings.customMetrics[index].id;
      if (!this.plugin.settings.customMetrics[index].name) {
        this.plugin.settings.customMetrics[index].name = { en: "", zh: "" };
      }
      this.plugin.settings.customMetrics[index].name.en = value || "Metric";
      const newId = this.generateMetricId(value || "Metric");
      this.plugin.settings.customMetrics[index].id = newId;
      if (oldId !== newId) {
        await this.updateMetricIdInAllDocuments(oldId, newId);
      }
      await this.saveSettings();
      this.refresh();
    }));
    new import_obsidian6.Setting(metricItem).setName("\u6307\u6807\u540D\u79F0\uFF08\u4E2D\u6587\uFF09").setDesc("\u8F93\u5165\u6B64\u6307\u6807\u7684\u4E2D\u6587\u540D\u79F0").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A\u91CD\u8981\u6027").setValue(metric.name.zh || "").onChange(async (value) => {
      if (!this.plugin.settings.customMetrics[index].name) {
        this.plugin.settings.customMetrics[index].name = { en: "", zh: "" };
      }
      this.plugin.settings.customMetrics[index].name.zh = value || "\u6307\u6807";
      await this.saveSettings();
    }));
    new import_obsidian6.Setting(metricItem).setName(i18n.t("settings.customMetrics.metricWeight")).setDesc(i18n.t("settings.customMetrics.description")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(metric.weight).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.customMetrics[index].weight = Math.floor(value);
      await this.normalizeMetricWeights();
      await this.saveSettings();
      this.refresh();
    }));
  }
  /**
   * 添加新指标
   */
  async addNewMetric() {
    var _a;
    const currentCount = ((_a = this.plugin.settings.customMetrics) == null ? void 0 : _a.length) || 0;
    if (currentCount >= 10) {
      new import_obsidian6.Notice(i18n.t("settings.customMetrics.maxMetricsWarning"));
      return;
    }
    try {
      const newMetric = {
        id: this.generateMetricId(`Metric${currentCount + 1}`),
        name: {
          en: `Metric ${currentCount + 1}`,
          zh: `\u6307\u6807${currentCount + 1}`
        },
        weight: Math.floor(100 / (currentCount + 1))
      };
      this.plugin.settings.customMetrics.push(newMetric);
      await this.normalizeMetricWeights();
      await this.addDefaultValuesForNewMetrics(currentCount, currentCount + 1);
      await this.saveSettings();
      this.refresh();
      new import_obsidian6.Notice(i18n.t("notices.settingsSaved"));
    } catch (error) {
      console.error("\u6DFB\u52A0\u6307\u6807\u5931\u8D25:", error);
      new import_obsidian6.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  /**
   * 删除指标
   */
  async deleteMetric(index) {
    const metricToDelete = this.plugin.settings.customMetrics[index];
    if (!metricToDelete) {
      console.warn("\u8981\u5220\u9664\u7684\u6307\u6807\u4E0D\u5B58\u5728\uFF0Cindex:", index);
      return;
    }
    try {
      const displayName = typeof metricToDelete.name === "string" ? metricToDelete.name : metricToDelete.name.zh || metricToDelete.name.en;
      console.log(`\u5F00\u59CB\u5220\u9664\u6307\u6807: ${displayName} (ID: ${metricToDelete.id})`);
      const confirmed = await this.showDeleteConfirmation(displayName);
      if (!confirmed) {
        console.log("\u7528\u6237\u53D6\u6D88\u4E86\u5220\u9664\u64CD\u4F5C");
        return;
      }
      this.plugin.settings.customMetrics.splice(index, 1);
      console.log("\u5DF2\u4ECE\u8BBE\u7F6E\u4E2D\u5220\u9664\u6307\u6807");
      await this.removeMetricFromAllDocuments(metricToDelete.id);
      console.log("\u5DF2\u4ECE\u6240\u6709\u6587\u6863\u4E2D\u5220\u9664\u6307\u6807\u6570\u636E");
      await this.normalizeMetricWeights();
      console.log("\u5DF2\u91CD\u65B0\u5F52\u4E00\u5316\u6743\u91CD");
      await this.saveSettings();
      console.log("\u5DF2\u4FDD\u5B58\u8BBE\u7F6E");
      this.refresh();
      console.log("\u5DF2\u5237\u65B0\u754C\u9762");
      new import_obsidian6.Notice(`\u2705 \u5DF2\u5220\u9664\u6307\u6807"${metricToDelete.name}"`);
    } catch (error) {
      console.error("\u5220\u9664\u6307\u6807\u5931\u8D25:", error);
      new import_obsidian6.Notice("\u5220\u9664\u6307\u6807\u5931\u8D25");
      try {
        this.refresh();
      } catch (refreshError) {
        console.error("\u5237\u65B0\u754C\u9762\u5931\u8D25:", refreshError);
      }
    }
  }
  /**
   * 显示删除确认对话框
   */
  async showDeleteConfirmation(metricName) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "delete-confirmation-modal";
      modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
      const content = document.createElement("div");
      content.className = "modal-content";
      content.style.cssText = `
                background-color: var(--background-primary);
                border: 1px solid var(--background-modifier-border);
                border-radius: 6px;
                padding: 20px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            `;
      content.innerHTML = `
                <h3 style="margin-top: 0; color: var(--text-normal);">${i18n.t("common.confirm")}</h3>
                <p style="color: var(--text-normal);">${i18n.t("settings.customMetrics.removeMetric")} "${metricName}"?</p>
                <p class="warning" style="color: var(--text-error); font-weight: bold;">\u26A0\uFE0F ${i18n.t("settings.dataManagement.clearConfirm")}</p>
                <div class="modal-buttons" style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                    <button class="cancel-btn" style="padding: 8px 16px; border: 1px solid var(--background-modifier-border); background-color: var(--interactive-normal); color: var(--text-normal); border-radius: 4px; cursor: pointer;">${i18n.t("common.cancel")}</button>
                    <button class="confirm-btn" style="padding: 8px 16px; border: none; background-color: var(--interactive-destructive); color: var(--text-on-accent); border-radius: 4px; cursor: pointer;">${i18n.t("common.delete")}</button>
                </div>
            `;
      modal.appendChild(content);
      document.body.appendChild(modal);
      const cancelBtn = content.querySelector(".cancel-btn");
      const confirmBtn = content.querySelector(".confirm-btn");
      const cleanup = () => {
        if (document.body.contains(modal)) {
          document.body.removeChild(modal);
        }
      };
      cancelBtn.onclick = () => {
        cleanup();
        resolve(false);
      };
      confirmBtn.onclick = () => {
        cleanup();
        resolve(true);
      };
      modal.onclick = (e) => {
        if (e.target === modal) {
          cleanup();
          resolve(false);
        }
      };
      const handleEsc = (e) => {
        if (e.key === "Escape") {
          document.removeEventListener("keydown", handleEsc);
          cleanup();
          resolve(false);
        }
      };
      document.addEventListener("keydown", handleEsc);
    });
  }
  /**
   * 从所有文档中删除指标数据
   */
  async removeMetricFromAllDocuments(metricId) {
    try {
      const roamingFiles = this.plugin.fileManagementService.getValidRoamingFiles();
      let removedCount = 0;
      let errorCount = 0;
      console.log(`\u5F00\u59CB\u4ECE ${roamingFiles.length} \u4E2A\u6587\u6863\u4E2D\u5220\u9664\u6307\u6807\u6570\u636E: ${metricId}`);
      for (const file of roamingFiles) {
        try {
          const currentMetrics = this.plugin.settings.documentMetrics[file.path];
          if (currentMetrics && currentMetrics.hasOwnProperty(metricId)) {
            delete currentMetrics[metricId];
            removedCount++;
            const remainingKeys = Object.keys(currentMetrics).filter(
              (key) => key !== "lastVisited" && key !== "visitCount"
            );
            if (remainingKeys.length === 0) {
              const basicInfo = {
                lastVisited: currentMetrics.lastVisited || Date.now(),
                visitCount: currentMetrics.visitCount || 0
              };
              this.plugin.settings.documentMetrics[file.path] = basicInfo;
            }
          }
        } catch (fileError) {
          console.error(`\u5904\u7406\u6587\u4EF6 ${file.path} \u65F6\u51FA\u9519:`, fileError);
          errorCount++;
        }
      }
      console.log(`\u6307\u6807\u5220\u9664\u5B8C\u6210: \u4ECE ${removedCount} \u4E2A\u6587\u6863\u4E2D\u5220\u9664\u4E86\u6570\u636E\uFF0C${errorCount} \u4E2A\u6587\u6863\u5904\u7406\u5931\u8D25`);
      if (errorCount > 0) {
        console.warn(`\u5220\u9664\u6307\u6807\u65F6\u9047\u5230 ${errorCount} \u4E2A\u9519\u8BEF\uFF0C\u4F46\u64CD\u4F5C\u7EE7\u7EED\u5B8C\u6210`);
      }
    } catch (error) {
      console.error(`\u5220\u9664\u6240\u6709\u6587\u6863\u4E2D\u7684\u6307\u6807\u6570\u636E\u65F6\u53D1\u751F\u4E25\u91CD\u9519\u8BEF:`, error);
      throw error;
    }
  }
  /**
   * 更新所有文档中的指标ID（当指标重命名时）
   */
  async updateMetricIdInAllDocuments(oldId, newId) {
    const roamingFiles = this.plugin.fileManagementService.getValidRoamingFiles();
    let updatedCount = 0;
    for (const file of roamingFiles) {
      const currentMetrics = this.plugin.settings.documentMetrics[file.path];
      if (currentMetrics && oldId in currentMetrics) {
        currentMetrics[newId] = currentMetrics[oldId];
        delete currentMetrics[oldId];
        updatedCount++;
      }
    }
    if (updatedCount > 0) {
      console.log(`\u5DF2\u5728 ${updatedCount} \u4E2A\u6587\u6863\u4E2D\u66F4\u65B0\u6307\u6807ID: ${oldId} -> ${newId}`);
    }
  }
  /**
   * 为现有文档添加新指标的默认值
   */
  async addDefaultValuesForNewMetrics(oldCount, newCount) {
    try {
      const roamingFiles = this.plugin.fileManagementService.getValidRoamingFiles();
      const allMetrics = this.plugin.settings.customMetrics;
      const newMetrics = allMetrics.slice(oldCount);
      if (newMetrics.length === 0)
        return;
      let updatedCount = 0;
      for (const file of roamingFiles) {
        let hasUpdates = false;
        const currentMetrics = this.plugin.settings.documentMetrics[file.path] || {
          lastVisited: Date.now(),
          visitCount: 0
        };
        for (const metric of newMetrics) {
          if (!(metric.id in currentMetrics)) {
            currentMetrics[metric.id] = 5;
            hasUpdates = true;
          }
        }
        if (hasUpdates) {
          this.plugin.settings.documentMetrics[file.path] = currentMetrics;
          updatedCount++;
        }
      }
      if (updatedCount > 0) {
        await this.plugin.saveSettings();
        new import_obsidian6.Notice(i18n.t("notices.settingsSaved"));
      }
    } catch (error) {
      console.error("\u4E3A\u65B0\u6307\u6807\u6DFB\u52A0\u9ED8\u8BA4\u503C\u5931\u8D25:", error);
      new import_obsidian6.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  async normalizeMetricWeights() {
    try {
      const metrics = this.plugin.settings.customMetrics;
      if (!metrics || metrics.length === 0) {
        console.log("\u6CA1\u6709\u81EA\u5B9A\u4E49\u6307\u6807\uFF0C\u8DF3\u8FC7\u6743\u91CD\u5F52\u4E00\u5316");
        return;
      }
      const totalWeight = metrics.reduce((sum, metric) => sum + metric.weight, 0);
      if (totalWeight > 0) {
        metrics.forEach((metric) => {
          metric.weight = Math.round(metric.weight / totalWeight * 100);
        });
        console.log(`\u5DF2\u5F52\u4E00\u5316 ${metrics.length} \u4E2A\u6307\u6807\u7684\u6743\u91CD\uFF0C\u603B\u6743\u91CD: 100%`);
      } else {
        const equalWeight = Math.floor(100 / metrics.length);
        metrics.forEach((metric) => {
          metric.weight = equalWeight;
        });
        console.log(`\u603B\u6743\u91CD\u4E3A0\uFF0C\u5DF2\u5E73\u5747\u5206\u914D\u6743\u91CD: ${equalWeight}%`);
      }
      this.plugin.settings.metricWeights = {};
      for (const metric of metrics) {
        this.plugin.settings.metricWeights[metric.id] = metric.weight;
      }
    } catch (error) {
      console.error("\u5F52\u4E00\u5316\u6743\u91CD\u65F6\u51FA\u9519:", error);
      throw error;
    }
  }
  generateMetricId(name) {
    return name.toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "") || "metric";
  }
  async saveSettings() {
    await this.plugin.saveSettings();
  }
  refresh() {
    try {
      console.log("\u5F00\u59CB\u5237\u65B0\u81EA\u5B9A\u4E49\u6307\u6807\u8BBE\u7F6E\u754C\u9762");
      if (this.contentEl) {
        this.render();
        console.log("\u81EA\u5B9A\u4E49\u6307\u6807\u8BBE\u7F6E\u754C\u9762\u5237\u65B0\u5B8C\u6210");
      } else {
        console.warn("\u5185\u5BB9\u5BB9\u5668\u4E0D\u5B58\u5728\uFF0C\u5C1D\u8BD5\u91CD\u65B0\u521B\u5EFA");
        this.contentEl = this.containerEl.createEl("div", { cls: "custom-metrics-settings-content" });
        this.render();
      }
    } catch (error) {
      console.error("\u5237\u65B0\u81EA\u5B9A\u4E49\u6307\u6807\u8BBE\u7F6E\u754C\u9762\u65F6\u51FA\u9519:", error);
      try {
        if (!this.contentEl) {
          this.contentEl = this.containerEl.createEl("div", { cls: "custom-metrics-settings-content" });
        }
        this.render();
      } catch (renderError) {
        console.error("\u91CD\u65B0\u6E32\u67D3\u4E5F\u5931\u8D25:", renderError);
      }
    }
  }
};

// src/settings/RecommendationSettings.ts
var import_obsidian7 = require("obsidian");
var RecommendationSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  render() {
    this.containerEl.createEl("h3", { text: i18n.t("settings.recommendation.title") });
    new import_obsidian7.Setting(this.containerEl).setName(i18n.t("settings.recommendation.recentCount")).setDesc(i18n.t("settings.recommendation.recentCountDesc")).addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.recommendationSettings.recentCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.recommendationSettings.recentCount = Math.floor(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(this.containerEl).setName(i18n.t("settings.recommendation.topCount")).setDesc(i18n.t("settings.recommendation.topCountDesc")).addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.recommendationSettings.topCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.recommendationSettings.topCount = Math.floor(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(this.containerEl).setName(i18n.t("settings.recommendation.topK")).setDesc(i18n.t("settings.recommendation.topKDesc")).addSlider((slider) => slider.setLimits(5, 50, 1).setValue(this.plugin.settings.recommendationSettings.topK).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.recommendationSettings.topK = Math.floor(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(this.containerEl).setName(i18n.t("settings.recommendation.maxCandidates")).setDesc(i18n.t("settings.recommendation.maxCandidatesDesc")).addSlider((slider) => slider.setLimits(50, 500, 10).setValue(this.plugin.settings.maxCandidates).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxCandidates = Math.floor(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(this.containerEl).setName(i18n.t("settings.recommendation.maxParagraphs")).setDesc(i18n.t("settings.recommendation.maxParagraphsDesc")).addSlider((slider) => slider.setLimits(3, 10, 1).setValue(this.plugin.settings.recommendationSettings.maxParagraphs).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.recommendationSettings.maxParagraphs = Math.floor(value);
      await this.plugin.saveSettings();
    }));
  }
};

// src/settings/FilterSettings.ts
var import_obsidian8 = require("obsidian");
var FilterSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  render() {
    this.containerEl.createEl("h3", { text: i18n.t("settings.filter.title") });
    new import_obsidian8.Setting(this.containerEl).setName(i18n.t("settings.filter.excludedPaths")).setDesc(i18n.t("settings.filter.excludedPathsDesc")).addTextArea((text) => text.setPlaceholder(i18n.t("settings.filter.excludedPathsPlaceholder")).setValue(this.plugin.settings.excludedPaths.join("\n")).onChange(async (value) => {
      this.plugin.settings.excludedPaths = value.split("\n").filter((p) => p.trim());
      await this.plugin.saveSettings();
    }));
  }
};

// src/settings/DataManagementSettings.ts
var import_obsidian9 = require("obsidian");
var DataManagementSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  render() {
    this.containerEl.createEl("h3", { text: i18n.t("settings.dataManagement.title") });
    new import_obsidian9.Setting(this.containerEl).setName(i18n.t("settings.dataManagement.clearHistory")).setDesc(i18n.t("settings.dataManagement.clearHistoryDesc")).addButton((button) => button.setButtonText(i18n.t("settings.dataManagement.clearButton")).onClick(async () => {
      if (confirm(i18n.t("settings.dataManagement.clearConfirm"))) {
        this.plugin.settings.roamingDocs = [];
        for (const [path] of Object.entries(this.plugin.settings.documentMetrics)) {
          this.plugin.settings.documentMetrics[path].visitCount = 0;
          this.plugin.settings.documentMetrics[path].lastVisited = 0;
        }
        await this.plugin.saveSettings();
        new import_obsidian9.Notice(i18n.t("notices.historyCleared"));
      }
    }));
  }
};

// src/settings/ColorSchemeSettings.ts
var import_obsidian10 = require("obsidian");
var ColorSchemeSettings = class {
  constructor(containerEl, plugin) {
    this.applyThemeTimeout = null;
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  render() {
    const colorSchemeContainer = this.containerEl.createEl("div", { cls: "color-scheme-settings-content" });
    colorSchemeContainer.createEl("h3", { text: "Color Theme" });
    new import_obsidian10.Setting(colorSchemeContainer).setName("Color Theme").setDesc("Select your preferred color scheme for the plugin interface").addDropdown((dropdown) => {
      COLOR_SCHEMES.forEach((scheme) => {
        const displayName = i18n.getLanguage() === "zh" ? scheme.name.zh : scheme.name.en;
        dropdown.addOption(scheme.id, displayName);
      });
      dropdown.setValue(this.plugin.settings.colorScheme || "arctic").onChange(async (value) => {
        this.plugin.settings.colorScheme = value;
        await this.plugin.saveSettings();
        this.applyColorScheme(value);
        clearTimeout(this.applyThemeTimeout);
        this.applyThemeTimeout = setTimeout(() => {
          this.plugin.notifyViewsRefreshUI();
        }, 100);
      });
    });
    this.createColorSchemePreview(colorSchemeContainer);
  }
  createColorSchemePreview(container) {
    const previewContainer = container.createEl("div", { cls: "color-scheme-preview" });
    previewContainer.createEl("h4", { text: "Theme Preview" });
    const previewGrid = previewContainer.createEl("div", { cls: "preview-grid" });
    COLOR_SCHEMES.forEach((scheme) => {
      const previewCard = previewGrid.createEl("div", { cls: "preview-card" });
      const colorDisplay = previewCard.createEl("div", { cls: "color-display" });
      colorDisplay.style.background = scheme.bgGradient;
      const primaryColor = colorDisplay.createEl("div", { cls: "color-swatch primary" });
      primaryColor.style.backgroundColor = scheme.primaryColor;
      const accentColor = colorDisplay.createEl("div", { cls: "color-swatch accent" });
      accentColor.style.backgroundColor = scheme.accentColor;
      const schemeName = i18n.getLanguage() === "zh" ? scheme.name.zh : scheme.name.en;
      const nameLabel = previewCard.createEl("div", { cls: "scheme-name", text: schemeName });
      previewCard.addEventListener("click", async () => {
        this.plugin.settings.colorScheme = scheme.id;
        await this.plugin.saveSettings();
        this.applyColorScheme(scheme.id);
        const dropdown = container.querySelector(".dropdown");
        if (dropdown) {
          dropdown.value = scheme.id;
        }
        previewGrid.querySelectorAll(".preview-card").forEach((card) => {
          card.classList.remove("selected");
        });
        previewCard.classList.add("selected");
        clearTimeout(this.applyThemeTimeout);
        this.applyThemeTimeout = setTimeout(() => {
          this.plugin.notifyViewsRefreshUI();
        }, 100);
      });
      if (scheme.id === (this.plugin.settings.colorScheme || "arctic")) {
        previewCard.classList.add("selected");
      }
    });
  }
  applyColorScheme(schemeId) {
    const scheme = COLOR_SCHEMES.find((s) => s.id === schemeId);
    if (!scheme)
      return;
    let styleEl = document.getElementById("incremental-reading-color-scheme");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.id = "incremental-reading-color-scheme";
      document.head.appendChild(styleEl);
    }
    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 142, g: 68, b: 173 };
    };
    const accentRgb = hexToRgb(scheme.accentColor);
    const primaryRgb = hexToRgb(scheme.primaryColor);
    const cssVariables = `
            :root {
                /* Primary Color Scheme */
                --primary-color: ${scheme.primaryColor};
                --accent-color: ${scheme.accentColor};
                --accent-light: ${scheme.primaryColor};
                --accent-dark: ${scheme.accentColor};

                /* Background Colors */
                --bg-gradient: ${scheme.bgGradient};
                --card-bg: ${scheme.cardBg};
                --card-hover-bg: ${scheme.cardBg};

                /* Text Colors */
                --text-main: ${scheme.textMain};
                --text-secondary: ${scheme.textSecondary};

                /* Accent Variations */
                --accent-transparent: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);
                --accent-light-transparent: rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, 0.1);
                --accent-dark-transparent: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);

                /* Box Shadows */
                --accent-shadow: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.3);
                --accent-shadow-hover: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.5);
                --accent-shadow-light: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);
                --accent-shadow-heavy: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.6);

                /* Borders */
                --accent-border: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.3);
                --accent-border-hover: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.4);
                --light-border: rgba(0,0,0,0.05);
                --medium-border: rgba(0,0,0,0.08);

                /* Gradients */
                --accent-gradient: linear-gradient(135deg, var(--accent-light) 0%, var(--accent-color) 100%);
                --accent-gradient-vertical: linear-gradient(180deg, var(--accent-light) 0%, var(--accent-color) 100%);
                --accent-gradient-horizontal: linear-gradient(90deg, var(--accent-light) 0%, var(--accent-color) 100%);

                /* Dimensions */
                --border-radius: 16px;
                --small-border-radius: 8px;
            }
        `;
    styleEl.textContent = cssVariables;
    const pluginContainers = document.querySelectorAll(".plugin-container");
    pluginContainers.forEach((container) => {
      container.style.background = scheme.bgGradient;
    });
  }
};

// src/main.ts
var IncrementalReadingPlugin = class extends import_obsidian11.Plugin {
  constructor() {
    super(...arguments);
    this.leaf = null;
    this.isUpdatingSettings = false;
  }
  async onload() {
    console.log("Loading Incremental Reading plugin");
    await this.loadSettings();
    i18n.setLanguage(this.settings.language || "en");
    this.applyColorScheme(this.settings.colorScheme || "arctic");
    this.recommendationService = new RecommendationService(this.app, this.settings);
    this.fileManagementService = new FileManagementService(this.app, this.settings);
    this.documentScoringService = new DocumentScoringService(this.settings);
    this.registerView(
      VIEW_TYPE_INCREMENTAL_READING,
      (leaf) => new IncrementalReadingView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Incremental Reading", () => {
      this.activateView();
    });
    this.addCommands();
    this.addSettingTab(new IncrementalReadingSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.leaf && this.leaf.detach) {
          this.leaf = null;
        }
      })
    );
  }
  onunload() {
    console.log("Unloading Incremental Reading plugin");
  }
  async loadSettings() {
    try {
      const savedSettings = await this.loadData();
      const validatedSettings = SharedUtils.validateSettings(savedSettings);
      this.settings = Object.assign({}, DEFAULT_SETTINGS, validatedSettings);
      if (!this.settings.version || this.settings.version !== DEFAULT_SETTINGS.version) {
        this.settings.roamingDocs = [];
        this.settings.version = DEFAULT_SETTINGS.version;
        await this.saveData(this.settings);
        new import_obsidian11.Notice('Plugin upgraded! Please re-add documents to roaming list using "Add to Roaming"');
      }
    } catch (error) {
      console.error("Error loading settings:", error);
      new import_obsidian11.Notice(i18n.t("notices.errorLoadingSettings"));
      this.settings = { ...DEFAULT_SETTINGS };
    }
  }
  async saveSettings() {
    if (this.isUpdatingSettings) {
      console.warn("Settings update already in progress, skipping");
      return;
    }
    this.isUpdatingSettings = true;
    try {
      const validatedSettings = SharedUtils.validateSettings(this.settings);
      Object.assign(this.settings, validatedSettings);
      await this.saveData(this.settings);
      this.recommendationService = new RecommendationService(this.app, this.settings);
      this.fileManagementService = new FileManagementService(this.app, this.settings);
      this.documentScoringService = new DocumentScoringService(this.settings);
      this.notifyViewsRefresh();
    } catch (error) {
      console.error("Error saving settings:", error);
      new import_obsidian11.Notice(i18n.t("notices.errorSavingSettings"));
    } finally {
      this.isUpdatingSettings = false;
    }
  }
  /**
   * 通知所有增量阅读视图刷新UI（用于语言切换）
   */
  notifyViewsRefreshUI() {
    try {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_INCREMENTAL_READING);
      leaves.forEach((leaf) => {
        const view = leaf.view;
        if (view && typeof view.refreshUI === "function") {
          view.refreshUI();
          console.log("\u5DF2\u901A\u77E5\u589E\u91CF\u9605\u8BFB\u89C6\u56FE\u5237\u65B0UI");
        }
      });
    } catch (error) {
      console.error("\u901A\u77E5\u89C6\u56FE\u5237\u65B0UI\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 通知所有增量阅读视图刷新数据
   */
  notifyViewsRefresh() {
    try {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_INCREMENTAL_READING);
      leaves.forEach((leaf) => {
        const view = leaf.view;
        if (view && typeof view.refreshData === "function") {
          view.refreshData();
          console.log("\u5DF2\u901A\u77E5\u589E\u91CF\u9605\u8BFB\u89C6\u56FE\u5237\u65B0\u6570\u636E");
        }
      });
    } catch (error) {
      console.error("\u901A\u77E5\u89C6\u56FE\u5237\u65B0\u65F6\u51FA\u9519:", error);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    if (this.leaf && !this.leaf.detach) {
      try {
        const existingLeaves2 = workspace.getLeavesOfType(VIEW_TYPE_INCREMENTAL_READING);
        if (existingLeaves2.includes(this.leaf)) {
          workspace.revealLeaf(this.leaf);
          return;
        }
      } catch (error) {
        console.warn("Error checking existing leaf:", error);
      }
    }
    const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_INCREMENTAL_READING);
    if (existingLeaves.length > 0) {
      this.leaf = existingLeaves[0];
      workspace.revealLeaf(this.leaf);
      return;
    }
    this.leaf = workspace.getRightLeaf(false);
    if (this.leaf) {
      await this.leaf.setViewState({ type: VIEW_TYPE_INCREMENTAL_READING, active: true });
      workspace.revealLeaf(this.leaf);
    }
  }
  addCommands() {
    this.addCommand({
      id: "start-incremental-reading",
      name: i18n.t("commands.startReading"),
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "open-random-document",
      name: i18n.t("commands.openRandom"),
      callback: () => {
        this.openRandomDocument();
      }
    });
    this.addCommand({
      id: "add-to-roaming",
      name: i18n.t("commands.addToRoaming"),
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian11.Notice(i18n.t("notices.noActiveFile"));
          return;
        }
        try {
          if (activeFile.extension !== "md") {
            new import_obsidian11.Notice(i18n.t("notices.onlyMarkdownFiles"));
            return;
          }
          if (!this.settings.roamingDocs.includes(activeFile.path)) {
            this.settings.roamingDocs.push(activeFile.path);
          }
          const defaultMetrics = this.fileManagementService.createDefaultMetricsForFile(activeFile);
          await this.updateDocumentMetrics(activeFile, defaultMetrics);
          await this.saveSettings();
          new import_obsidian11.Notice(i18n.t("notices.addedToRoaming", { filename: activeFile.basename }));
        } catch (error) {
          console.error("\u52A0\u5165\u6F2B\u6E38\u5931\u8D25:", error);
          new import_obsidian11.Notice(i18n.t("notices.errorSavingSettings"));
        }
      }
    });
    this.addCommand({
      id: "add-folder-to-roaming",
      name: i18n.t("commands.addFolder"),
      callback: async () => {
        new import_obsidian11.Notice(i18n.t("view.actionBar.addFolder"));
      }
    });
    this.addCommand({
      id: "add-multiple-files-to-roaming",
      name: i18n.t("commands.addMultiple"),
      callback: async () => {
        new import_obsidian11.Notice(i18n.t("view.actionBar.multiSelect"));
      }
    });
    this.addCommand({
      id: "reset-visited-documents",
      name: i18n.t("commands.clearHistory"),
      callback: async () => {
        this.settings.roamingDocs = [];
        for (const [path] of Object.entries(this.settings.documentMetrics)) {
          this.settings.documentMetrics[path].visitCount = 0;
          this.settings.documentMetrics[path].lastVisited = 0;
        }
        await this.saveSettings();
        new import_obsidian11.Notice(i18n.t("notices.historyCleared"));
      }
    });
  }
  async openRandomDocument() {
    try {
      const randomFile = this.fileManagementService.getRandomUnvisitedFile();
      if (!randomFile) {
        new import_obsidian11.Notice(i18n.t("view.actionBar.noDocuments"));
        return;
      }
      await this.app.workspace.getLeaf().openFile(randomFile);
    } catch (error) {
      console.error("Error opening random document:", error);
      new import_obsidian11.Notice(i18n.t("notices.documentOpenFailed"));
    }
  }
  // 公共方法供视图组件使用
  getDocumentMetrics(file) {
    return this.documentScoringService.getDocumentMetrics(file);
  }
  async updateDocumentMetrics(file, metrics) {
    try {
      const validatedMetrics = this.documentScoringService.validateMetrics(metrics);
      const updatedMetrics = this.documentScoringService.updateDocumentMetrics(file, validatedMetrics);
      this.settings.documentMetrics[file.path] = updatedMetrics;
      await this.saveSettings();
    } catch (error) {
      console.error("Error updating document metrics:", error);
      new import_obsidian11.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  getRecommendedDocuments(limit = 10) {
    try {
      const validRoamingPaths = this.fileManagementService.getValidRoamingPaths();
      const validRoamingFiles = this.fileManagementService.getValidRoamingFiles();
      const filteredFiles = validRoamingFiles.filter(
        (file) => this.fileManagementService.shouldIncludeFile(file)
      );
      return this.documentScoringService.getRecommendedDocuments(filteredFiles, limit);
    } catch (error) {
      console.error("Error getting recommended documents:", error);
      return [];
    }
  }
  // 公开服务实例
  get FileManagementService() {
    return this.fileManagementService;
  }
  get DocumentScoringService() {
    return this.documentScoringService;
  }
  // 向后兼容的方法
  getValidRoamingFiles() {
    return this.fileManagementService.getValidRoamingFiles();
  }
  getValidRoamingPaths() {
    return this.fileManagementService.getValidRoamingPaths();
  }
  async addFoldersToRoaming(folderPaths) {
    try {
      const addedCount = await this.fileManagementService.addFoldersToRoaming(folderPaths);
      await this.saveSettings();
      new import_obsidian11.Notice(i18n.t("notices.filesAdded", { count: addedCount }));
    } catch (error) {
      console.error("\u6DFB\u52A0\u6587\u4EF6\u5939\u5931\u8D25:", error);
      new import_obsidian11.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  async addMultipleFilesToRoaming(files) {
    try {
      const addedCount = await this.fileManagementService.addMultipleFilesToRoaming(files);
      await this.saveSettings();
      new import_obsidian11.Notice(i18n.t("notices.filesAdded", { count: addedCount }));
    } catch (error) {
      console.error("\u6DFB\u52A0\u6587\u4EF6\u5931\u8D25:", error);
      new import_obsidian11.Notice(i18n.t("notices.errorSavingSettings"));
    }
  }
  /**
   * 应用颜色主题
   */
  applyColorScheme(schemeId) {
    const scheme = COLOR_SCHEMES.find((s) => s.id === schemeId);
    if (!scheme)
      return;
    let styleEl = document.getElementById("incremental-reading-color-scheme");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.id = "incremental-reading-color-scheme";
      document.head.appendChild(styleEl);
    }
    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 142, g: 68, b: 173 };
    };
    const accentRgb = hexToRgb(scheme.accentColor);
    const primaryRgb = hexToRgb(scheme.primaryColor);
    const cssVariables = `
            :root {
                /* Primary Color Scheme */
                --primary-color: ${scheme.primaryColor};
                --accent-color: ${scheme.accentColor};
                --accent-light: ${scheme.primaryColor};
                --accent-dark: ${scheme.accentColor};

                /* Background Colors */
                --bg-gradient: ${scheme.bgGradient};
                --card-bg: ${scheme.cardBg};
                --card-hover-bg: ${scheme.cardBg};

                /* Text Colors */
                --text-main: ${scheme.textMain};
                --text-secondary: ${scheme.textSecondary};

                /* Accent Variations */
                --accent-transparent: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);
                --accent-light-transparent: rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, 0.1);
                --accent-dark-transparent: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);

                /* Box Shadows */
                --accent-shadow: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.3);
                --accent-shadow-hover: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.5);
                --accent-shadow-light: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.1);
                --accent-shadow-heavy: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.6);

                /* Borders */
                --accent-border: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.3);
                --accent-border-hover: rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0.4);
                --light-border: rgba(0,0,0,0.05);
                --medium-border: rgba(0,0,0,0.08);

                /* Gradients */
                --accent-gradient: linear-gradient(135deg, var(--accent-light) 0%, var(--accent-color) 100%);
                --accent-gradient-vertical: linear-gradient(180deg, var(--accent-light) 0%, var(--accent-color) 100%);
                --accent-gradient-horizontal: linear-gradient(90deg, var(--accent-light) 0%, var(--accent-color) 100%);

                /* Dimensions */
                --border-radius: 16px;
                --small-border-radius: 8px;
            }
        `;
    styleEl.textContent = cssVariables;
    const pluginContainers = document.querySelectorAll(".plugin-container");
    pluginContainers.forEach((container) => {
      container.style.background = scheme.bgGradient;
    });
  }
};
var IncrementalReadingSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("setting-tab-content");
    containerEl.addClass("incremental-reading-settings");
    containerEl.addClass("incremental-reading-plugin-root");
    containerEl.createEl("h2", { text: i18n.t("settings.title") });
    containerEl.createEl("h3", { text: i18n.t("settings.general.title") });
    new import_obsidian11.Setting(containerEl).setName(i18n.t("settings.general.language")).setDesc(i18n.t("settings.general.languageDesc")).addDropdown((dropdown) => {
      const languages = i18n.getAvailableLanguages();
      languages.forEach((lang) => {
        dropdown.addOption(lang.code, lang.name);
      });
      dropdown.setValue(this.plugin.settings.language || "en").onChange(async (value) => {
        this.plugin.settings.language = value;
        i18n.setLanguage(value);
        await this.plugin.saveSettings();
        this.display();
        this.plugin.notifyViewsRefreshUI();
        new import_obsidian11.Notice(i18n.t("notices.settingsSaved"));
      });
    });
    const colorSchemeSettings = new ColorSchemeSettings(containerEl, this.plugin);
    colorSchemeSettings.render();
    const customMetricsSettings = new CustomMetricsSettings(containerEl, this.plugin);
    customMetricsSettings.render();
    const recommendationSettings = new RecommendationSettings(containerEl, this.plugin);
    recommendationSettings.render();
    const filterSettings = new FilterSettings(containerEl, this.plugin);
    filterSettings.render();
    const dataManagementSettings = new DataManagementSettings(containerEl, this.plugin);
    dataManagementSettings.render();
  }
};
